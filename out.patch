diff --git a/boring/Cargo.toml b/boring/Cargo.toml
index d76c9294..465cbb29 100644
--- a/boring/Cargo.toml
+++ b/boring/Cargo.toml
@@ -10,7 +10,7 @@ readme = "README.md"
 keywords = ["crypto", "tls", "ssl", "dtls"]
 categories = ["cryptography", "api-bindings"]
 edition = { workspace = true }
-rust-version = "1.80"
+rust-version = { workspace = true }
 
 [package.metadata.docs.rs]
 features = ["rpk", "underscore-wildcards"]
@@ -25,6 +25,10 @@ fips = ["boring-sys/fips"]
 # **DO NOT USE** This will be removed without warning in future releases.
 legacy-compat-deprecated = []
 
+# **DO NOT USE** This will be removed without warning in future releases.
+# PQ is always enabled. This feature is a no-op, only for backwards compatibility.
+pq-experimental = []
+
 # Enables Raw public key API (https://datatracker.ietf.org/doc/html/rfc7250)
 # This feature is necessary in order to compile the bindings for the
 # default branch of boringSSL. Alternatively, a version of boringSSL that
diff --git a/boring/src/aes.rs b/boring/src/aes.rs
index 8a47cbaf..e535fa21 100644
--- a/boring/src/aes.rs
+++ b/boring/src/aes.rs
@@ -38,7 +38,7 @@
 //! ```
 //!
 use crate::ffi;
-use libc::{c_int, c_uint, size_t};
+use libc::c_int;
 use openssl_macros::corresponds;
 use std::mem::MaybeUninit;
 use std::ptr;
@@ -63,8 +63,8 @@ impl AesKey {
 
             let mut aes_key = MaybeUninit::uninit();
             let r = ffi::AES_set_encrypt_key(
-                key.as_ptr() as *const _,
-                key.len() as c_uint * 8,
+                key.as_ptr(),
+                (key.len() * 8).try_into().map_err(|_| KeyError(()))?,
                 aes_key.as_mut_ptr(),
             );
             if r == 0 {
@@ -87,8 +87,8 @@ impl AesKey {
 
             let mut aes_key = MaybeUninit::uninit();
             let r = ffi::AES_set_decrypt_key(
-                key.as_ptr() as *const _,
-                key.len() as c_uint * 8,
+                key.as_ptr(),
+                (key.len() * 8).try_into().map_err(|_| KeyError(()))?,
                 aes_key.as_mut_ptr(),
             );
 
@@ -125,12 +125,11 @@ pub fn wrap_key(
         assert!(out.len() >= in_.len() + 8); // Ciphertext is 64 bits longer (see 2.2.1)
 
         let written = ffi::AES_wrap_key(
-            &key.0 as *const _ as *mut _, // this is safe, the implementation only uses the key as a const pointer.
-            iv.as_ref()
-                .map_or(ptr::null(), |iv| iv.as_ptr() as *const _),
-            out.as_ptr() as *mut _,
-            in_.as_ptr() as *const _,
-            in_.len() as size_t,
+            std::ptr::addr_of!(key.0).cast_mut(), // this is safe, the implementation only uses the key as a const pointer.
+            iv.as_ref().map_or(ptr::null(), |iv| iv.as_ptr()),
+            out.as_mut_ptr(),
+            in_.as_ptr(),
+            in_.len(),
         );
         if written <= 0 {
             Err(KeyError(()))
@@ -164,12 +163,11 @@ pub fn unwrap_key(
         assert!(out.len() + 8 <= in_.len());
 
         let written = ffi::AES_unwrap_key(
-            &key.0 as *const _ as *mut _, // this is safe, the implementation only uses the key as a const pointer.
-            iv.as_ref()
-                .map_or(ptr::null(), |iv| iv.as_ptr() as *const _),
-            out.as_ptr() as *mut _,
-            in_.as_ptr() as *const _,
-            in_.len() as size_t,
+            std::ptr::addr_of!(key.0).cast_mut(), // this is safe, the implementation only uses the key as a const pointer.
+            iv.as_ref().map_or(ptr::null(), |iv| iv.as_ptr().cast()),
+            out.as_ptr().cast_mut(),
+            in_.as_ptr().cast(),
+            in_.len(),
         );
 
         if written <= 0 {
diff --git a/boring/src/asn1.rs b/boring/src/asn1.rs
index d9929ef7..27f375f2 100644
--- a/boring/src/asn1.rs
+++ b/boring/src/asn1.rs
@@ -26,7 +26,7 @@
 //! ```
 use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
-use libc::{c_char, c_int, c_long, time_t};
+use libc::{c_int, c_long, time_t};
 use std::cmp::Ordering;
 use std::ffi::CString;
 use std::fmt;
@@ -315,7 +315,10 @@ impl Asn1Time {
         ffi::init();
 
         unsafe {
-            let handle = cvt_p(ffi::ASN1_TIME_set(ptr::null_mut(), time))?;
+            // for higher musl version, need to convert i32 to i64
+            // https://github.com/rust-lang/libc/issues/1848
+            #[allow(clippy::useless_conversion)]
+            let handle = cvt_p(ffi::ASN1_TIME_set(ptr::null_mut(), time.into()))?;
             Ok(Asn1Time::from_ptr(handle))
         }
     }
@@ -405,7 +408,7 @@ impl Asn1StringRef {
                 return Err(ErrorStack::get());
             }
 
-            Ok(OpensslString::from_ptr(ptr as *mut c_char))
+            Ok(OpensslString::from_ptr(ptr.cast()))
         }
     }
 
@@ -505,7 +508,6 @@ impl Asn1IntegerRef {
                 self.as_ptr(),
                 c_long::from(value),
             ))
-            .map(|_| ())
         }
     }
 }
@@ -547,7 +549,7 @@ impl Asn1BitStringRef {
     #[corresponds(ASN1_STRING_length)]
     #[must_use]
     pub fn len(&self) -> usize {
-        unsafe { ffi::ASN1_STRING_length(self.as_ptr() as *const _) as usize }
+        unsafe { ffi::ASN1_STRING_length(self.as_ptr().cast_const()) as usize }
     }
 
     /// Determines if the string is empty.
@@ -589,7 +591,7 @@ impl Asn1Object {
         unsafe {
             ffi::init();
             let txt = CString::new(txt).map_err(ErrorStack::internal_error)?;
-            let obj: *mut ffi::ASN1_OBJECT = cvt_p(ffi::OBJ_txt2obj(txt.as_ptr() as *const _, 0))?;
+            let obj: *mut ffi::ASN1_OBJECT = cvt_p(ffi::OBJ_txt2obj(txt.as_ptr(), 0))?;
             Ok(Asn1Object::from_ptr(obj))
         }
     }
@@ -606,9 +608,9 @@ impl Asn1ObjectRef {
 impl fmt::Display for Asn1ObjectRef {
     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
         unsafe {
-            let mut buf = [0; 80];
+            let mut buf = [0u8; 80];
             let len = ffi::OBJ_obj2txt(
-                buf.as_mut_ptr() as *mut _,
+                buf.as_mut_ptr().cast(),
                 buf.len() as c_int,
                 self.as_ptr(),
                 0,
diff --git a/boring/src/bio.rs b/boring/src/bio.rs
index 2e6b2572..bb4aa1a5 100644
--- a/boring/src/bio.rs
+++ b/boring/src/bio.rs
@@ -1,11 +1,12 @@
-use crate::ffi;
-use crate::ffi::BIO_new_mem_buf;
 use std::marker::PhantomData;
 use std::ptr;
 use std::slice;
 
 use crate::cvt_p;
 use crate::error::ErrorStack;
+use crate::ffi;
+use crate::ffi::BIO_new_mem_buf;
+use crate::try_int;
 
 pub struct MemBioSlice<'a>(*mut ffi::BIO, PhantomData<&'a [u8]>);
 
@@ -19,20 +20,9 @@ impl Drop for MemBioSlice<'_> {
 
 impl<'a> MemBioSlice<'a> {
     pub fn new(buf: &'a [u8]) -> Result<MemBioSlice<'a>, ErrorStack> {
-        #[cfg(not(feature = "legacy-compat-deprecated"))]
-        type BufLen = isize;
-        #[cfg(feature = "legacy-compat-deprecated")]
-        type BufLen = libc::c_int;
-
         ffi::init();
 
-        assert!(buf.len() <= BufLen::MAX as usize);
-        let bio = unsafe {
-            cvt_p(BIO_new_mem_buf(
-                buf.as_ptr() as *const _,
-                buf.len() as BufLen,
-            ))?
-        };
+        let bio = unsafe { cvt_p(BIO_new_mem_buf(buf.as_ptr().cast(), try_int(buf.len())?))? };
 
         Ok(MemBioSlice(bio, PhantomData))
     }
@@ -68,7 +58,7 @@ impl MemBio {
         unsafe {
             let mut ptr = ptr::null_mut();
             let len = ffi::BIO_get_mem_data(self.0, &mut ptr);
-            if ptr.is_null() {
+            if ptr.is_null() || len < 0 {
                 return &[];
             }
             slice::from_raw_parts(ptr.cast_const().cast(), len as usize)
diff --git a/boring/src/bn.rs b/boring/src/bn.rs
index bf4ca1c7..545eb348 100644
--- a/boring/src/bn.rs
+++ b/boring/src/bn.rs
@@ -24,7 +24,7 @@
 //! [`BIGNUM`]: https://wiki.openssl.org/index.php/Manual:Bn_internal(3)
 use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
-use libc::{c_int, size_t};
+use libc::c_int;
 use std::cmp::Ordering;
 use std::ffi::CString;
 use std::ops::{Add, Deref, Div, Mul, Neg, Rem, Shl, Shr, Sub};
@@ -121,19 +121,19 @@ impl BigNumRef {
     /// Adds a `u32` to `self`.
     #[corresponds(BN_add_word)]
     pub fn add_word(&mut self, w: u32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_add_word(self.as_ptr(), ffi::BN_ULONG::from(w))).map(|_| ()) }
+        unsafe { cvt(ffi::BN_add_word(self.as_ptr(), ffi::BN_ULONG::from(w))) }
     }
 
     /// Subtracts a `u32` from `self`.
     #[corresponds(BN_sub_word)]
     pub fn sub_word(&mut self, w: u32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_sub_word(self.as_ptr(), ffi::BN_ULONG::from(w))).map(|_| ()) }
+        unsafe { cvt(ffi::BN_sub_word(self.as_ptr(), ffi::BN_ULONG::from(w))) }
     }
 
     /// Multiplies a `u32` by `self`.
     #[corresponds(BN_mul_word)]
     pub fn mul_word(&mut self, w: u32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_mul_word(self.as_ptr(), ffi::BN_ULONG::from(w))).map(|_| ()) }
+        unsafe { cvt(ffi::BN_mul_word(self.as_ptr(), ffi::BN_ULONG::from(w))) }
     }
 
     /// Divides `self` by a `u32`, returning the remainder.
@@ -168,13 +168,13 @@ impl BigNumRef {
     /// number less than `self` in `rnd`.
     #[corresponds(BN_rand_range)]
     pub fn rand_range(&self, rnd: &mut BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_rand_range(rnd.as_ptr(), self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_rand_range(rnd.as_ptr(), self.as_ptr())) }
     }
 
     /// The cryptographically weak counterpart to `rand_in_range`.
     #[corresponds(BN_pseudo_rand_range)]
     pub fn pseudo_rand_range(&self, rnd: &mut BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_pseudo_rand_range(rnd.as_ptr(), self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_pseudo_rand_range(rnd.as_ptr(), self.as_ptr())) }
     }
 
     /// Sets bit `n`. Equivalent to `self |= (1 << n)`.
@@ -183,7 +183,7 @@ impl BigNumRef {
     #[corresponds(BN_set_bit)]
     #[allow(clippy::useless_conversion)]
     pub fn set_bit(&mut self, n: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_set_bit(self.as_ptr(), n.into())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_set_bit(self.as_ptr(), n.into())) }
     }
 
     /// Clears bit `n`, setting it to 0. Equivalent to `self &= ~(1 << n)`.
@@ -192,7 +192,7 @@ impl BigNumRef {
     #[corresponds(BN_clear_bit)]
     #[allow(clippy::useless_conversion)]
     pub fn clear_bit(&mut self, n: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_clear_bit(self.as_ptr(), n.into())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_clear_bit(self.as_ptr(), n.into())) }
     }
 
     /// Returns `true` if the `n`th bit of `self` is set to 1, `false` otherwise.
@@ -209,19 +209,19 @@ impl BigNumRef {
     #[corresponds(BN_mask_bits)]
     #[allow(clippy::useless_conversion)]
     pub fn mask_bits(&mut self, n: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_mask_bits(self.as_ptr(), n.into())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_mask_bits(self.as_ptr(), n.into())) }
     }
 
     /// Places `a << 1` in `self`.  Equivalent to `self * 2`.
     #[corresponds(BN_lshift1)]
     pub fn lshift1(&mut self, a: &BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_lshift1(self.as_ptr(), a.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_lshift1(self.as_ptr(), a.as_ptr())) }
     }
 
     /// Places `a >> 1` in `self`. Equivalent to `self / 2`.
     #[corresponds(BN_rshift1)]
     pub fn rshift1(&mut self, a: &BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_rshift1(self.as_ptr(), a.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_rshift1(self.as_ptr(), a.as_ptr())) }
     }
 
     /// Places `a + b` in `self`.  [`core::ops::Add`] is also implemented for `BigNumRef`.
@@ -229,7 +229,7 @@ impl BigNumRef {
     /// [`core::ops::Add`]: struct.BigNumRef.html#method.add
     #[corresponds(BN_add)]
     pub fn checked_add(&mut self, a: &BigNumRef, b: &BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_add(self.as_ptr(), a.as_ptr(), b.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_add(self.as_ptr(), a.as_ptr(), b.as_ptr())) }
     }
 
     /// Places `a - b` in `self`. [`core::ops::Sub`] is also implemented for `BigNumRef`.
@@ -237,21 +237,21 @@ impl BigNumRef {
     /// [`core::ops::Sub`]: struct.BigNumRef.html#method.sub
     #[corresponds(BN_sub)]
     pub fn checked_sub(&mut self, a: &BigNumRef, b: &BigNumRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_sub(self.as_ptr(), a.as_ptr(), b.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_sub(self.as_ptr(), a.as_ptr(), b.as_ptr())) }
     }
 
     /// Places `a << n` in `self`.  Equivalent to `a * 2 ^ n`.
     #[corresponds(BN_lshift)]
     #[allow(clippy::useless_conversion)]
     pub fn lshift(&mut self, a: &BigNumRef, n: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_lshift(self.as_ptr(), a.as_ptr(), n.into())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_lshift(self.as_ptr(), a.as_ptr(), n.into())) }
     }
 
     /// Places `a >> n` in `self`. Equivalent to `a / 2 ^ n`.
     #[corresponds(BN_rshift)]
     #[allow(clippy::useless_conversion)]
     pub fn rshift(&mut self, a: &BigNumRef, n: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_rshift(self.as_ptr(), a.as_ptr(), n.into())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_rshift(self.as_ptr(), a.as_ptr(), n.into())) }
     }
 
     /// Creates a new BigNum with the same value.
@@ -339,7 +339,6 @@ impl BigNumRef {
                 msb.0,
                 c_int::from(odd),
             ))
-            .map(|_| ())
         }
     }
 
@@ -354,7 +353,6 @@ impl BigNumRef {
                 msb.0,
                 c_int::from(odd),
             ))
-            .map(|_| ())
         }
     }
 
@@ -392,13 +390,12 @@ impl BigNumRef {
         unsafe {
             cvt(ffi::BN_generate_prime_ex(
                 self.as_ptr(),
-                bits as c_int,
+                c_int::from(bits),
                 c_int::from(safe),
                 add.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut()),
                 rem.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut()),
                 ptr::null_mut(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -420,7 +417,6 @@ impl BigNumRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -443,7 +439,6 @@ impl BigNumRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -463,7 +458,6 @@ impl BigNumRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -484,14 +478,13 @@ impl BigNumRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
     /// Places the result of `aÂ²` in `self`.
     #[corresponds(BN_sqr)]
     pub fn sqr(&mut self, a: &BigNumRef, ctx: &mut BigNumContextRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::BN_sqr(self.as_ptr(), a.as_ptr(), ctx.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::BN_sqr(self.as_ptr(), a.as_ptr(), ctx.as_ptr())) }
     }
 
     /// Places the result of `a mod m` in `self`.  As opposed to `div_rem`
@@ -510,7 +503,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -531,7 +523,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -552,7 +543,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -573,7 +563,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -592,7 +581,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -611,7 +599,6 @@ impl BigNumRef {
                 p.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -632,7 +619,6 @@ impl BigNumRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -670,7 +656,6 @@ impl BigNumRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -846,7 +831,7 @@ impl BigNum {
             ffi::init();
             let c_str = CString::new(s.as_bytes()).map_err(ErrorStack::internal_error)?;
             let mut bn = ptr::null_mut();
-            cvt(ffi::BN_dec2bn(&mut bn, c_str.as_ptr() as *const _))?;
+            cvt(ffi::BN_dec2bn(&mut bn, c_str.as_ptr()))?;
             Ok(BigNum::from_ptr(bn))
         }
     }
@@ -858,7 +843,7 @@ impl BigNum {
             ffi::init();
             let c_str = CString::new(s.as_bytes()).map_err(ErrorStack::internal_error)?;
             let mut bn = ptr::null_mut();
-            cvt(ffi::BN_hex2bn(&mut bn, c_str.as_ptr() as *const _))?;
+            cvt(ffi::BN_hex2bn(&mut bn, c_str.as_ptr()))?;
             Ok(BigNum::from_ptr(bn))
         }
     }
@@ -880,12 +865,7 @@ impl BigNum {
         unsafe {
             ffi::init();
             assert!(n.len() <= c_int::MAX as usize);
-            cvt_p(ffi::BN_bin2bn(
-                n.as_ptr(),
-                n.len() as size_t,
-                ptr::null_mut(),
-            ))
-            .map(|p| BigNum::from_ptr(p))
+            cvt_p(ffi::BN_bin2bn(n.as_ptr(), n.len(), ptr::null_mut())).map(|p| BigNum::from_ptr(p))
         }
     }
 }
diff --git a/boring/src/derive.rs b/boring/src/derive.rs
index 1952118d..a094c66d 100644
--- a/boring/src/derive.rs
+++ b/boring/src/derive.rs
@@ -44,7 +44,7 @@ impl<'a> Deriver<'a> {
     where
         T: HasPublic,
     {
-        unsafe { cvt(ffi::EVP_PKEY_derive_set_peer(self.0, key.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::EVP_PKEY_derive_set_peer(self.0, key.as_ptr())) }
     }
 
     /// Returns the size of the shared secret.
@@ -64,14 +64,7 @@ impl<'a> Deriver<'a> {
     #[corresponds(EVP_PKEY_derive)]
     pub fn derive(&mut self, buf: &mut [u8]) -> Result<usize, ErrorStack> {
         let mut len = buf.len();
-        unsafe {
-            cvt(ffi::EVP_PKEY_derive(
-                self.0,
-                buf.as_mut_ptr() as *mut _,
-                &mut len,
-            ))
-            .map(|_| len)
-        }
+        unsafe { cvt(ffi::EVP_PKEY_derive(self.0, buf.as_mut_ptr(), &mut len)).map(|_| len) }
     }
 
     /// A convenience function which derives a shared secret and returns it in a new buffer.
diff --git a/boring/src/dsa.rs b/boring/src/dsa.rs
index be13da9f..36562699 100644
--- a/boring/src/dsa.rs
+++ b/boring/src/dsa.rs
@@ -5,7 +5,6 @@
 //! using the private key that can be validated with the public key but not be generated
 //! without the private key.
 
-use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
 use libc::c_uint;
 use openssl_macros::corresponds;
@@ -15,7 +14,9 @@ use std::ptr;
 
 use crate::bn::{BigNum, BigNumRef};
 use crate::error::ErrorStack;
+use crate::ffi;
 use crate::pkey::{HasParams, HasPrivate, HasPublic, Private, Public};
+use crate::try_int;
 use crate::{cvt, cvt_p};
 
 generic_foreign_type_and_impl_send_sync! {
@@ -103,7 +104,7 @@ where
         unsafe {
             let mut pub_key = ptr::null();
             DSA_get0_key(self.as_ptr(), &mut pub_key, ptr::null_mut());
-            BigNumRef::from_ptr(pub_key as *mut _)
+            BigNumRef::from_ptr(pub_key.cast_mut())
         }
     }
 }
@@ -132,7 +133,7 @@ where
         unsafe {
             let mut priv_key = ptr::null();
             DSA_get0_key(self.as_ptr(), ptr::null_mut(), &mut priv_key);
-            BigNumRef::from_ptr(priv_key as *mut _)
+            BigNumRef::from_ptr(priv_key.cast_mut())
         }
     }
 }
@@ -154,7 +155,7 @@ where
         unsafe {
             let mut p = ptr::null();
             DSA_get0_pqg(self.as_ptr(), &mut p, ptr::null_mut(), ptr::null_mut());
-            BigNumRef::from_ptr(p as *mut _)
+            BigNumRef::from_ptr(p.cast_mut())
         }
     }
 
@@ -164,7 +165,7 @@ where
         unsafe {
             let mut q = ptr::null();
             DSA_get0_pqg(self.as_ptr(), ptr::null_mut(), &mut q, ptr::null_mut());
-            BigNumRef::from_ptr(q as *mut _)
+            BigNumRef::from_ptr(q.cast_mut())
         }
     }
 
@@ -174,7 +175,7 @@ where
         unsafe {
             let mut g = ptr::null();
             DSA_get0_pqg(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut g);
-            BigNumRef::from_ptr(g as *mut _)
+            BigNumRef::from_ptr(g.cast_mut())
         }
     }
 }
@@ -195,7 +196,7 @@ impl Dsa<Private> {
             let dsa = Dsa::from_ptr(cvt_p(ffi::DSA_new())?);
             cvt(ffi::DSA_generate_parameters_ex(
                 dsa.0,
-                bits as c_uint,
+                c_uint::from(bits),
                 ptr::null(),
                 0,
                 ptr::null_mut(),
@@ -300,7 +301,7 @@ mod test {
         let mut ctx = BigNumContext::new().unwrap();
         let mut calc = BigNum::new().unwrap();
         calc.mod_exp(g, priv_key, p, &mut ctx).unwrap();
-        assert_eq!(&calc, pub_key)
+        assert_eq!(&calc, pub_key);
     }
 
     #[test]
diff --git a/boring/src/ec.rs b/boring/src/ec.rs
index 588408aa..477f6d06 100644
--- a/boring/src/ec.rs
+++ b/boring/src/ec.rs
@@ -15,7 +15,6 @@
 //! [`EcGroup`]: struct.EcGroup.html
 //! [`Nid`]: ../nid/struct.Nid.html
 //! [Eliptic Curve Cryptography]: https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography
-use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
 use libc::c_int;
 use openssl_macros::corresponds;
@@ -24,8 +23,10 @@ use std::ptr;
 
 use crate::bn::{BigNumContextRef, BigNumRef};
 use crate::error::ErrorStack;
+use crate::ffi;
 use crate::nid::Nid;
 use crate::pkey::{HasParams, HasPrivate, HasPublic, Params, Private, Public};
+use crate::try_int;
 use crate::{cvt, cvt_n, cvt_p, init};
 
 /// Compressed or Uncompressed conversion
@@ -143,7 +144,6 @@ impl EcGroupRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -160,7 +160,6 @@ impl EcGroupRef {
                 cofactor.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -185,7 +184,7 @@ impl EcGroupRef {
     pub fn generator(&self) -> &EcPointRef {
         unsafe {
             let ptr = ffi::EC_GROUP_get0_generator(self.as_ptr());
-            EcPointRef::from_ptr(ptr as *mut _)
+            EcPointRef::from_ptr(ptr.cast_mut())
         }
     }
 
@@ -202,7 +201,6 @@ impl EcGroupRef {
                 order.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -260,7 +258,6 @@ impl EcPointRef {
                 b.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -283,7 +280,6 @@ impl EcPointRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -304,7 +300,6 @@ impl EcPointRef {
                 ptr::null(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -326,7 +321,6 @@ impl EcPointRef {
                 m.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -339,7 +333,6 @@ impl EcPointRef {
                 self.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -428,7 +421,6 @@ impl EcPointRef {
                 y.as_ptr(),
                 ctx.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 }
@@ -506,7 +498,7 @@ where
     pub fn private_key(&self) -> &BigNumRef {
         unsafe {
             let ptr = ffi::EC_KEY_get0_private_key(self.as_ptr());
-            BigNumRef::from_ptr(ptr as *mut _)
+            BigNumRef::from_ptr(ptr.cast_mut())
         }
     }
 }
@@ -521,7 +513,7 @@ where
     pub fn public_key(&self) -> &EcPointRef {
         unsafe {
             let ptr = ffi::EC_KEY_get0_public_key(self.as_ptr());
-            EcPointRef::from_ptr(ptr as *mut _)
+            EcPointRef::from_ptr(ptr.cast_mut())
         }
     }
 
@@ -552,14 +544,14 @@ where
     pub fn group(&self) -> &EcGroupRef {
         unsafe {
             let ptr = ffi::EC_KEY_get0_group(self.as_ptr());
-            EcGroupRef::from_ptr(ptr as *mut _)
+            EcGroupRef::from_ptr(ptr.cast_mut())
         }
     }
 
     /// Checks the key for validity.
     #[corresponds(EC_KEY_check_key)]
     pub fn check_key(&self) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::EC_KEY_check_key(self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::EC_KEY_check_key(self.as_ptr())) }
     }
 }
 
diff --git a/boring/src/ecdsa.rs b/boring/src/ecdsa.rs
index 4d5bb097..27be5c51 100644
--- a/boring/src/ecdsa.rs
+++ b/boring/src/ecdsa.rs
@@ -2,7 +2,7 @@
 
 use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
-use libc::{c_int, size_t};
+use libc::c_int;
 use openssl_macros::corresponds;
 use std::mem;
 use std::ptr;
@@ -36,10 +36,10 @@ impl EcdsaSig {
             assert!(data.len() <= c_int::MAX as usize);
             let sig = cvt_p(ffi::ECDSA_do_sign(
                 data.as_ptr(),
-                data.len() as size_t,
+                data.len(),
                 eckey.as_ptr(),
             ))?;
-            Ok(EcdsaSig::from_ptr(sig as *mut _))
+            Ok(EcdsaSig::from_ptr(sig))
         }
     }
 
@@ -51,7 +51,7 @@ impl EcdsaSig {
             let sig = cvt_p(ffi::ECDSA_SIG_new())?;
             ECDSA_SIG_set0(sig, r.as_ptr(), s.as_ptr());
             mem::forget((r, s));
-            Ok(EcdsaSig::from_ptr(sig as *mut _))
+            Ok(EcdsaSig::from_ptr(sig))
         }
     }
 
@@ -83,7 +83,7 @@ impl EcdsaSigRef {
             assert!(data.len() <= c_int::MAX as usize);
             cvt_n(ffi::ECDSA_do_verify(
                 data.as_ptr(),
-                data.len() as size_t,
+                data.len(),
                 self.as_ptr(),
                 eckey.as_ptr(),
             ))
@@ -98,7 +98,7 @@ impl EcdsaSigRef {
         unsafe {
             let mut r = ptr::null();
             ECDSA_SIG_get0(self.as_ptr(), &mut r, ptr::null_mut());
-            BigNumRef::from_ptr(r as *mut _)
+            BigNumRef::from_ptr(r.cast_mut())
         }
     }
 
@@ -109,7 +109,7 @@ impl EcdsaSigRef {
         unsafe {
             let mut s = ptr::null();
             ECDSA_SIG_get0(self.as_ptr(), ptr::null_mut(), &mut s);
-            BigNumRef::from_ptr(s as *mut _)
+            BigNumRef::from_ptr(s.cast_mut())
         }
     }
 }
diff --git a/boring/src/error.rs b/boring/src/error.rs
index 1e8f7946..5087d10f 100644
--- a/boring/src/error.rs
+++ b/boring/src/error.rs
@@ -193,7 +193,7 @@ impl Error {
                 self.line,
             );
             if let Some(cstr) = self.data_cstr() {
-                ffi::ERR_set_error_data(cstr.as_ptr().cast_mut(), ffi::ERR_FLAG_STRING);
+                ffi::ERR_add_error_data(1, cstr.as_ptr().cast_mut());
             }
         }
     }
diff --git a/boring/src/hash.rs b/boring/src/hash.rs
index 5deadade..543e401f 100644
--- a/boring/src/hash.rs
+++ b/boring/src/hash.rs
@@ -1,7 +1,5 @@
-use crate::ffi;
 use openssl_macros::corresponds;
-use std::convert::TryInto;
-use std::ffi::{c_uint, c_void};
+use std::ffi::c_uint;
 use std::fmt;
 use std::io;
 use std::io::prelude::*;
@@ -9,8 +7,10 @@ use std::ops::{Deref, DerefMut};
 use std::ptr;
 
 use crate::error::ErrorStack;
+use crate::ffi;
 use crate::ffi::{EVP_MD_CTX_free, EVP_MD_CTX_new};
 use crate::nid::Nid;
+use crate::try_int;
 use crate::{cvt, cvt_p};
 
 #[derive(Copy, Clone, PartialEq, Eq)]
@@ -196,7 +196,7 @@ impl Hasher {
         unsafe {
             cvt(ffi::EVP_DigestUpdate(
                 self.ctx,
-                data.as_ptr() as *mut _,
+                data.as_ptr().cast_mut().cast(),
                 data.len(),
             ))?;
         }
@@ -210,7 +210,7 @@ impl Hasher {
             self.init()?;
         }
         unsafe {
-            let mut len = ffi::EVP_MAX_MD_SIZE.try_into().unwrap();
+            let mut len = try_int(ffi::EVP_MAX_MD_SIZE)?;
             let mut buf = [0; ffi::EVP_MAX_MD_SIZE as usize];
             cvt(ffi::EVP_DigestFinal_ex(
                 self.ctx,
@@ -220,7 +220,7 @@ impl Hasher {
             self.state = Finalized;
             Ok(DigestBytes {
                 buf,
-                len: len as usize,
+                len: try_int(len)?,
             })
         }
     }
@@ -359,7 +359,7 @@ pub fn hmac_sha1(key: &[u8], data: &[u8]) -> Result<[u8; 20], ErrorStack> {
     hmac(MessageDigest::sha1(), key, data)
 }
 
-fn hmac<const N: usize>(
+pub(crate) fn hmac<const N: usize>(
     digest: MessageDigest,
     key: &[u8],
     data: &[u8],
@@ -370,7 +370,7 @@ fn hmac<const N: usize>(
     cvt_p(unsafe {
         ffi::HMAC(
             digest.as_ptr(),
-            key.as_ptr() as *const c_void,
+            key.as_ptr().cast(),
             key.len(),
             data.as_ptr(),
             data.len(),
diff --git a/boring/src/hmac.rs b/boring/src/hmac.rs
index 7e50e613..a015409c 100644
--- a/boring/src/hmac.rs
+++ b/boring/src/hmac.rs
@@ -2,6 +2,7 @@ use crate::cvt;
 use crate::error::ErrorStack;
 use crate::foreign_types::ForeignTypeRef;
 use crate::hash::MessageDigest;
+use openssl_macros::corresponds;
 
 foreign_type_and_impl_send_sync! {
     type CType = ffi::HMAC_CTX;
@@ -13,7 +14,7 @@ foreign_type_and_impl_send_sync! {
 impl HmacCtxRef {
     /// Configures HmacCtx to use `md` as the hash function and `key` as the key.
     ///
-    /// https://commondatastorage.googleapis.com/chromium-boringssl-docs/hmac.h.html#HMAC_Init_ex
+    #[corresponds(HMAC_Init_ex)]
     pub fn init(&mut self, key: &[u8], md: &MessageDigest) -> Result<(), ErrorStack> {
         ffi::init();
 
@@ -26,7 +27,104 @@ impl HmacCtxRef {
                 // ENGINE api is deprecated
                 core::ptr::null_mut(),
             ))
-            .map(|_| ())
         }
     }
 }
+
+/// Provides an init-update-finalize API for HMAC.
+pub struct Hmac(*mut ffi::HMAC_CTX);
+
+impl Hmac {
+    /// Creates a new HMAC object with the given key and hash algorithm.
+    pub fn init(key: &[u8], md: &MessageDigest) -> Result<Hmac, ErrorStack> {
+        ffi::init();
+
+        let ctx = unsafe {
+            let ctx = ffi::HMAC_CTX_new();
+            cvt(ffi::HMAC_Init_ex(
+                ctx,
+                key.as_ptr().cast(),
+                key.len(),
+                md.as_ptr(),
+                // ENGINE api is deprecated
+                core::ptr::null_mut(),
+            ))?;
+            ctx
+        };
+
+        Ok(Hmac(ctx))
+    }
+
+    /// Updates the HMAC input.
+    pub fn update(&mut self, data: &[u8]) -> Result<(), ErrorStack> {
+        unsafe { cvt(ffi::HMAC_Update(self.0, data.as_ptr().cast(), data.len())) }
+    }
+
+    /// Finalizes the HMAC and returns the output.
+    pub fn finalize(self) -> Result<Vec<u8>, ErrorStack> {
+        let out_len = unsafe { ffi::HMAC_size(self.0) };
+        let mut out = vec![0; out_len];
+        unsafe {
+            cvt(ffi::HMAC_Final(
+                self.0,
+                out.as_mut_ptr().cast(),
+                // ENGINE api is deprecated
+                core::ptr::null_mut(),
+            ))?;
+        }
+        Ok(out)
+    }
+}
+
+impl Drop for Hmac {
+    fn drop(&mut self) {
+        unsafe { ffi::HMAC_CTX_free(self.0) }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use crate::hash;
+
+    use super::*;
+
+    fn test<const N: usize>(md: MessageDigest) {
+        assert_eq!(N, md.size());
+        let key = vec![0; N];
+        let message_parts = [
+            b"hello".to_vec(),
+            b"world!".to_vec(),
+            b"".to_vec(),
+            vec![0; 23],
+            b"fella guy".to_vec(),
+        ];
+        let message = message_parts.concat();
+
+        let mut hmac = Hmac::init(&key, &md).unwrap();
+        for part in &message_parts {
+            hmac.update(part).unwrap();
+        }
+        let res = hmac.finalize().unwrap();
+        assert_eq!(res, hash::hmac::<N>(md, &key, &message).unwrap());
+    }
+
+    #[test]
+    fn test_sha1() {
+        test::<20>(MessageDigest::sha1());
+    }
+
+    #[test]
+    fn test_sha256() {
+        test::<32>(MessageDigest::sha256());
+    }
+
+    #[test]
+    fn test_sha384() {
+        test::<48>(MessageDigest::sha384());
+    }
+
+    #[test]
+    fn test_sha512() {
+        test::<64>(MessageDigest::sha512());
+    }
+}
diff --git a/boring/src/lib.rs b/boring/src/lib.rs
index 932bdd35..d1d87e59 100644
--- a/boring/src/lib.rs
+++ b/boring/src/lib.rs
@@ -96,8 +96,6 @@
 //! Presently all these key agreements are deployed by Cloudflare, but we do not guarantee continued
 //! support for them.
 
-#![cfg_attr(docsrs, feature(doc_auto_cfg))]
-
 #[macro_use]
 extern crate bitflags;
 #[macro_use]
@@ -108,13 +106,12 @@ extern crate libc;
 #[cfg(test)]
 extern crate hex;
 
-use std::ffi::{c_long, c_void};
+use std::ffi::{c_int, c_long, c_void};
+use std::num::NonZeroUsize;
 
 #[doc(inline)]
 pub use crate::ffi::init;
 
-use libc::{c_int, size_t};
-
 use crate::error::ErrorStack;
 
 #[macro_use]
@@ -140,6 +137,7 @@ pub mod hash;
 pub mod hmac;
 pub mod hpke;
 pub mod memcmp;
+pub mod mlkem;
 pub mod nid;
 pub mod pkcs12;
 pub mod pkcs5;
@@ -164,11 +162,11 @@ fn cvt_p<T>(r: *mut T) -> Result<*mut T, ErrorStack> {
     }
 }
 
-fn cvt_0(r: size_t) -> Result<size_t, ErrorStack> {
+fn cvt_0(r: usize) -> Result<(), ErrorStack> {
     if r == 0 {
         Err(ErrorStack::get())
     } else {
-        Ok(r)
+        Ok(())
     }
 }
 
@@ -180,14 +178,21 @@ fn cvt_0i(r: c_int) -> Result<c_int, ErrorStack> {
     }
 }
 
-fn cvt(r: c_int) -> Result<c_int, ErrorStack> {
+fn cvt(r: c_int) -> Result<(), ErrorStack> {
     if r <= 0 {
         Err(ErrorStack::get())
     } else {
-        Ok(r)
+        Ok(())
     }
 }
 
+fn cvt_nz(r: c_int) -> Result<NonZeroUsize, ErrorStack> {
+    usize::try_from(r)
+        .ok()
+        .and_then(NonZeroUsize::new)
+        .ok_or_else(ErrorStack::get)
+}
+
 fn cvt_n(r: c_int) -> Result<c_int, ErrorStack> {
     if r < 0 {
         Err(ErrorStack::get())
@@ -196,6 +201,15 @@ fn cvt_n(r: c_int) -> Result<c_int, ErrorStack> {
     }
 }
 
+fn try_int<F, T>(from: F) -> Result<T, ErrorStack>
+where
+    F: TryInto<T> + Send + Sync + Copy + 'static,
+    T: Send + Sync + Copy + 'static,
+{
+    from.try_into()
+        .map_err(|_| ErrorStack::internal_error_str("int overflow"))
+}
+
 unsafe extern "C" fn free_data_box<T>(
     _parent: *mut c_void,
     ptr: *mut c_void,
@@ -205,6 +219,6 @@ unsafe extern "C" fn free_data_box<T>(
     _argp: *mut c_void,
 ) {
     if !ptr.is_null() {
-        drop(Box::<T>::from_raw(ptr as *mut T));
+        drop(Box::<T>::from_raw(ptr.cast::<T>()));
     }
 }
diff --git a/boring/src/macros.rs b/boring/src/macros.rs
index b6cbeb8f..f5bffae2 100644
--- a/boring/src/macros.rs
+++ b/boring/src/macros.rs
@@ -7,7 +7,8 @@ macro_rules! private_key_from_pem {
             unsafe {
                 ffi::init();
                 let bio = crate::bio::MemBioSlice::new(pem)?;
-                let passphrase = ::std::ffi::CString::new(passphrase).unwrap();
+                let passphrase = ::std::ffi::CString::new(passphrase)
+                    .map_err(crate::error::ErrorStack::internal_error)?;
                 cvt_p($f(bio.as_ptr(),
                          ptr::null_mut(),
                          None,
@@ -27,7 +28,7 @@ macro_rules! private_key_from_pem {
                 cvt_p($f(bio.as_ptr(),
                          ptr::null_mut(),
                          Some(crate::util::invoke_passwd_cb::<F>),
-                         &mut cb as *mut _ as *mut _))
+                         ptr::from_mut(&mut cb).cast()))
                     .map(|p| ::foreign_types::ForeignType::from_ptr(p))
             }
         }
@@ -59,12 +60,11 @@ macro_rules! private_key_to_pem {
         ) -> Result<Vec<u8>, crate::error::ErrorStack> {
             unsafe {
                 let bio = crate::bio::MemBio::new()?;
-                assert!(passphrase.len() <= ::libc::c_int::MAX as usize);
                 cvt($f(bio.as_ptr(),
                         self.as_ptr(),
                         cipher.as_ptr(),
                         passphrase.as_ptr() as *const _ as *mut _,
-                        passphrase.len() as ::libc::c_int,
+                        try_int(passphrase.len())?,
                         None,
                         ptr::null_mut()))?;
                 Ok(bio.get_buf().to_owned())
@@ -91,9 +91,9 @@ macro_rules! to_der {
         $(#[$m])*
         pub fn $n(&self) -> Result<Vec<u8>, crate::error::ErrorStack> {
             unsafe {
-                let len = crate::cvt($f(::foreign_types::ForeignTypeRef::as_ptr(self),
+                let len = crate::cvt_nz($f(::foreign_types::ForeignTypeRef::as_ptr(self),
                                         ptr::null_mut()))?;
-                let mut buf = vec![0; len as usize];
+                let mut buf = vec![0; len.get()];
                 crate::cvt($f(::foreign_types::ForeignTypeRef::as_ptr(self),
                               &mut buf.as_mut_ptr()))?;
                 Ok(buf)
diff --git a/boring/src/memcmp.rs b/boring/src/memcmp.rs
index 99cefdbe..4ac08b65 100644
--- a/boring/src/memcmp.rs
+++ b/boring/src/memcmp.rs
@@ -30,7 +30,6 @@
 //! assert!(!eq(&a, &c));
 //! ```
 use crate::ffi;
-use libc::size_t;
 
 /// Returns `true` iff `a` and `b` contain the same bytes.
 ///
@@ -64,13 +63,7 @@ use libc::size_t;
 #[must_use]
 pub fn eq(a: &[u8], b: &[u8]) -> bool {
     assert!(a.len() == b.len());
-    let ret = unsafe {
-        ffi::CRYPTO_memcmp(
-            a.as_ptr() as *const _,
-            b.as_ptr() as *const _,
-            a.len() as size_t,
-        )
-    };
+    let ret = unsafe { ffi::CRYPTO_memcmp(a.as_ptr().cast(), b.as_ptr().cast(), a.len()) };
     ret == 0
 }
 
diff --git a/boring/src/mlkem.rs b/boring/src/mlkem.rs
new file mode 100644
index 00000000..f5b84147
--- /dev/null
+++ b/boring/src/mlkem.rs
@@ -0,0 +1,767 @@
+//! ML-KEM (FIPS 203) post-quantum key encapsulation.
+//!
+//! ML-KEM is a low-level cryptographic primitive. For most applications,
+//! using higher-level constructions like HPKE is preferred.
+//! Note that it's also enabled in TLS by default, in the X25519MLKEM768 exchange.
+//!
+//! Provides ML-KEM-768 (recommended) and ML-KEM-1024 variants via [`Algorithm`].
+//!
+//! ```
+//! use boring::mlkem::{Algorithm, MlKemPrivateKey};
+//!
+//! let (public_key, private_key) = MlKemPrivateKey::generate(Algorithm::MlKem768).unwrap();
+//! let (ciphertext, shared_secret) = public_key.encapsulate().unwrap();
+//! let decrypted = private_key.decapsulate(&ciphertext).unwrap();
+//! assert_eq!(shared_secret, decrypted);
+//! ```
+
+use std::fmt;
+use std::mem::MaybeUninit;
+
+use crate::cvt;
+use crate::error::ErrorStack;
+use crate::ffi;
+
+// CBS_init is inline in BoringSSL, so bindgen can't generate bindings for it.
+#[inline]
+fn cbs_init(data: &[u8]) -> ffi::CBS {
+    ffi::CBS {
+        data: data.as_ptr(),
+        len: data.len(),
+    }
+}
+
+/// Private key seed size (64 bytes).
+pub const PRIVATE_KEY_SEED_BYTES: usize = ffi::MLKEM_SEED_BYTES as usize;
+
+/// Shared secret size (32 bytes).
+pub const SHARED_SECRET_BYTES: usize = ffi::MLKEM_SHARED_SECRET_BYTES as usize;
+
+/// Raw bytes of the private key seed ([`PRIVATE_KEY_SEED_BYTES`] long)
+pub type MlKemPrivateKeySeed = [u8; PRIVATE_KEY_SEED_BYTES];
+
+/// Raw bytes of the shared secret ([`SHARED_SECRET_BYTES`] long)
+pub type MlKemSharedSecret = [u8; SHARED_SECRET_BYTES];
+
+/// ML-KEM runtime algorithm selection.
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum Algorithm {
+    /// Recommended. AES-192 equivalent security.
+    MlKem768,
+    /// AES-256 equivalent security.
+    MlKem1024,
+}
+
+impl Algorithm {
+    /// Returns 1184 for ML-KEM-768, 1568 for ML-KEM-1024.
+    #[must_use]
+    pub const fn public_key_bytes(&self) -> usize {
+        match self {
+            Self::MlKem768 => MlKem768PublicKey::PUBLIC_KEY_BYTES,
+            Self::MlKem1024 => MlKem1024PublicKey::PUBLIC_KEY_BYTES,
+        }
+    }
+
+    /// Returns 1088 for ML-KEM-768, 1568 for ML-KEM-1024.
+    #[must_use]
+    pub const fn ciphertext_bytes(&self) -> usize {
+        match self {
+            Self::MlKem768 => MlKem768PrivateKey::CIPHERTEXT_BYTES,
+            Self::MlKem1024 => MlKem1024PrivateKey::CIPHERTEXT_BYTES,
+        }
+    }
+}
+
+#[derive(Clone)]
+pub struct MlKemPublicKey(Either<Box<MlKem768PublicKey>, Box<MlKem1024PublicKey>>);
+
+#[derive(Clone)]
+pub struct MlKemPrivateKey(Either<Box<MlKem768PrivateKey>, Box<MlKem1024PrivateKey>>);
+
+#[derive(Clone)]
+enum Either<T768, T1024> {
+    MlKem768(T768),
+    MlKem1024(T1024),
+}
+
+impl MlKemPrivateKey {
+    /// Generates a new key pair, returning `(public_key, private_key)`.
+    ///
+    /// The private key is a 64-byte seed. Keep it secret.
+    pub fn generate(algorithm: Algorithm) -> Result<(MlKemPublicKey, MlKemPrivateKey), ErrorStack> {
+        match algorithm {
+            Algorithm::MlKem768 => {
+                let (pk, sk) = MlKem768PrivateKey::generate();
+                Ok((
+                    MlKemPublicKey(Either::MlKem768(pk)),
+                    MlKemPrivateKey(Either::MlKem768(sk)),
+                ))
+            }
+            Algorithm::MlKem1024 => {
+                let (pk, sk) = MlKem1024PrivateKey::generate();
+                Ok((
+                    MlKemPublicKey(Either::MlKem1024(pk)),
+                    MlKemPrivateKey(Either::MlKem1024(sk)),
+                ))
+            }
+        }
+    }
+}
+
+impl MlKemPublicKey {
+    pub fn from_slice(algorithm: Algorithm, public_key: &[u8]) -> Result<Self, ErrorStack> {
+        match algorithm {
+            Algorithm::MlKem768 => Ok(Self(Either::MlKem768(Box::new(
+                MlKem768PublicKey::from_slice(public_key)?,
+            )))),
+            Algorithm::MlKem1024 => Ok(Self(Either::MlKem1024(Box::new(
+                MlKem1024PublicKey::from_slice(public_key)?,
+            )))),
+        }
+    }
+
+    /// Serialized bytes of the public key
+    pub fn as_bytes(&self) -> &[u8] {
+        match &self.0 {
+            Either::MlKem768(pk) => &pk.bytes,
+            Either::MlKem1024(pk) => &pk.bytes,
+        }
+    }
+
+    /// Encapsulates a shared secret to the given public key, returning
+    /// `(ciphertext, shared_secret)`.
+    pub fn encapsulate(&self) -> Result<(Vec<u8>, MlKemSharedSecret), ErrorStack> {
+        match &self.0 {
+            Either::MlKem768(pk) => {
+                let (ct, ss) = pk.encapsulate();
+                Ok((ct.to_vec(), ss))
+            }
+            Either::MlKem1024(pk) => {
+                let (ct, ss) = pk.encapsulate();
+                Ok((ct.to_vec(), ss))
+            }
+        }
+    }
+
+    /// Query public key and ciphertext length
+    pub fn algorithm(&self) -> Algorithm {
+        match self.0 {
+            Either::MlKem768(_) => Algorithm::MlKem768,
+            Either::MlKem1024(_) => Algorithm::MlKem1024,
+        }
+    }
+}
+
+impl MlKemPrivateKey {
+    /// Expand private key from the seed bytes
+    pub fn from_seed(
+        algorithm: Algorithm,
+        private_seed: &MlKemPrivateKeySeed,
+    ) -> Result<Self, ErrorStack> {
+        match algorithm {
+            Algorithm::MlKem768 => Ok(Self(Either::MlKem768(Box::new(
+                MlKem768PrivateKey::from_seed(private_seed)?,
+            )))),
+            Algorithm::MlKem1024 => Ok(Self(Either::MlKem1024(Box::new(
+                MlKem1024PrivateKey::from_seed(private_seed)?,
+            )))),
+        }
+    }
+
+    /// Secret seed bytes of this private key
+    pub fn seed_bytes(&self) -> &MlKemPrivateKeySeed {
+        match &self.0 {
+            Either::MlKem768(sk) => &sk.seed,
+            Either::MlKem1024(sk) => &sk.seed,
+        }
+    }
+
+    /// Decapsulates a shared secret from a ciphertext using the private key.
+    pub fn decapsulate(&self, ciphertext: &[u8]) -> Result<MlKemSharedSecret, ErrorStack> {
+        match &self.0 {
+            Either::MlKem768(sk) => {
+                let ct: &[u8; MlKem768PrivateKey::CIPHERTEXT_BYTES] = ciphertext
+                    .try_into()
+                    .map_err(|_| ErrorStack::internal_error_str("invalid ciphertext length"))?;
+                Ok(sk.decapsulate(ct))
+            }
+            Either::MlKem1024(sk) => {
+                let ct: &[u8; MlKem1024PrivateKey::CIPHERTEXT_BYTES] = ciphertext
+                    .try_into()
+                    .map_err(|_| ErrorStack::internal_error_str("invalid ciphertext length"))?;
+                Ok(sk.decapsulate(ct))
+            }
+        }
+    }
+
+    /// Query public key and ciphertext length
+    pub fn algorithm(&self) -> Algorithm {
+        match self.0 {
+            Either::MlKem768(_) => Algorithm::MlKem768,
+            Either::MlKem1024(_) => Algorithm::MlKem1024,
+        }
+    }
+}
+
+/// ML-KEM-768 private key.
+///
+/// Caches the expanded key for fast decapsulation.
+struct MlKem768PrivateKey {
+    seed: MlKemPrivateKeySeed,
+    expanded: ffi::MLKEM768_private_key,
+}
+
+impl Clone for MlKem768PrivateKey {
+    fn clone(&self) -> Self {
+        // unwrap is safe: cloning a valid key with a valid seed always succeeds
+        Self::from_seed(&self.seed).unwrap()
+    }
+}
+
+impl MlKem768PrivateKey {
+    pub const CIPHERTEXT_BYTES: usize = ffi::MLKEM768_CIPHERTEXT_BYTES as usize;
+
+    /// Generate a new key pair.
+    #[must_use]
+    fn generate() -> (Box<MlKem768PublicKey>, Box<MlKem768PrivateKey>) {
+        // SAFETY: all buffers are out parameters, correctly sized
+        unsafe {
+            ffi::init();
+            let mut public_key_bytes: MaybeUninit<[u8; MlKem768PublicKey::PUBLIC_KEY_BYTES]> =
+                MaybeUninit::uninit();
+            let mut seed: MaybeUninit<MlKemPrivateKeySeed> = MaybeUninit::uninit();
+            let mut expanded: MaybeUninit<ffi::MLKEM768_private_key> = MaybeUninit::uninit();
+
+            ffi::MLKEM768_generate_key(
+                public_key_bytes.as_mut_ptr().cast(),
+                seed.as_mut_ptr().cast(),
+                expanded.as_mut_ptr(),
+            );
+
+            let bytes = public_key_bytes.assume_init();
+
+            // Parse the public key bytes to get the parsed struct
+            let mut cbs = cbs_init(&bytes);
+            let mut parsed: MaybeUninit<ffi::MLKEM768_public_key> = MaybeUninit::uninit();
+            ffi::MLKEM768_parse_public_key(parsed.as_mut_ptr(), &mut cbs);
+
+            (
+                Box::new(MlKem768PublicKey {
+                    bytes,
+                    parsed: parsed.assume_init(),
+                }),
+                Box::new(MlKem768PrivateKey {
+                    seed: seed.assume_init(),
+                    expanded: expanded.assume_init(),
+                }),
+            )
+        }
+    }
+
+    /// Restore private key from seed.
+    fn from_seed(seed: &MlKemPrivateKeySeed) -> Result<Self, ErrorStack> {
+        // SAFETY: seed is 64 bytes, out parameter correctly sized
+        unsafe {
+            ffi::init();
+            let mut expanded: MaybeUninit<ffi::MLKEM768_private_key> = MaybeUninit::uninit();
+            cvt(ffi::MLKEM768_private_key_from_seed(
+                expanded.as_mut_ptr(),
+                seed.as_ptr(),
+                seed.len(),
+            ))?;
+            Ok(Self {
+                seed: *seed,
+                expanded: expanded.assume_init(),
+            })
+        }
+    }
+
+    /// Derive the public key.
+    #[cfg(test)]
+    fn public_key(&self) -> Result<MlKem768PublicKey, ErrorStack> {
+        // SAFETY: expanded key is valid, buffers correctly sized
+        unsafe {
+            ffi::init();
+            let mut parsed: MaybeUninit<ffi::MLKEM768_public_key> = MaybeUninit::uninit();
+            ffi::MLKEM768_public_from_private(parsed.as_mut_ptr(), &self.expanded);
+
+            let mut bytes = [0u8; MlKem768PublicKey::PUBLIC_KEY_BYTES];
+            let mut cbb: MaybeUninit<ffi::CBB> = MaybeUninit::uninit();
+            cvt(ffi::CBB_init_fixed(
+                cbb.as_mut_ptr(),
+                bytes.as_mut_ptr(),
+                bytes.len(),
+            ))?;
+            cvt(ffi::MLKEM768_marshal_public_key(
+                cbb.as_mut_ptr(),
+                parsed.as_ptr(),
+            ))?;
+
+            Ok(MlKem768PublicKey {
+                bytes,
+                parsed: parsed.assume_init(),
+            })
+        }
+    }
+
+    /// Decapsulate to get the shared secret.
+    fn decapsulate(&self, ciphertext: &[u8; Self::CIPHERTEXT_BYTES]) -> MlKemSharedSecret {
+        // SAFETY: expanded key is valid, ciphertext is correctly sized
+        unsafe {
+            ffi::init();
+            let mut shared_secret = [0u8; SHARED_SECRET_BYTES];
+
+            ffi::MLKEM768_decap(
+                shared_secret.as_mut_ptr(),
+                ciphertext.as_ptr(),
+                ciphertext.len(),
+                &self.expanded,
+            );
+
+            shared_secret
+        }
+    }
+}
+
+impl fmt::Debug for MlKem768PrivateKey {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("MlKem768PrivateKey")
+            .field("key", &"[redacted]")
+            .finish()
+    }
+}
+
+impl Drop for MlKem768PrivateKey {
+    fn drop(&mut self) {
+        // SAFETY: pointers and lengths are valid
+        unsafe {
+            ffi::OPENSSL_cleanse(self.seed.as_mut_ptr().cast(), self.seed.len());
+            ffi::OPENSSL_cleanse(
+                self.expanded.opaque.bytes.as_mut_ptr().cast(),
+                self.expanded.opaque.bytes.len(),
+            );
+        }
+    }
+}
+
+/// ML-KEM-768 public key.
+#[derive(Clone)]
+struct MlKem768PublicKey {
+    bytes: [u8; Self::PUBLIC_KEY_BYTES],
+    parsed: ffi::MLKEM768_public_key,
+}
+
+impl MlKem768PublicKey {
+    pub const PUBLIC_KEY_BYTES: usize = ffi::MLKEM768_PUBLIC_KEY_BYTES as usize;
+
+    /// Parse and validate a public key.
+    ///
+    /// The slice must be [`Self::PUBLIC_KEY_BYTES`] long.
+    fn from_slice(slice: &[u8]) -> Result<Self, ErrorStack> {
+        if slice.len() != Self::PUBLIC_KEY_BYTES {
+            return Err(ErrorStack::internal_error_str("invalid public key length"));
+        }
+
+        // SAFETY: CBS correctly initialized, length already checked
+        unsafe {
+            ffi::init();
+            let mut cbs = cbs_init(slice);
+            let mut parsed: MaybeUninit<ffi::MLKEM768_public_key> = MaybeUninit::uninit();
+
+            cvt(ffi::MLKEM768_parse_public_key(
+                parsed.as_mut_ptr(),
+                &mut cbs,
+            ))?;
+            if cbs.len != 0 {
+                return Err(ErrorStack::internal_error_str(
+                    "trailing bytes after public key",
+                ));
+            }
+
+            let mut bytes = [0u8; Self::PUBLIC_KEY_BYTES];
+            bytes.copy_from_slice(slice);
+            Ok(Self {
+                bytes,
+                parsed: parsed.assume_init(),
+            })
+        }
+    }
+
+    /// Encapsulate: returns (ciphertext, shared_secret).
+    fn encapsulate(
+        &self,
+    ) -> (
+        [u8; MlKem768PrivateKey::CIPHERTEXT_BYTES],
+        MlKemSharedSecret,
+    ) {
+        // SAFETY: buffers correctly sized, parsed key is valid
+        unsafe {
+            ffi::init();
+            let mut ciphertext = [0u8; MlKem768PrivateKey::CIPHERTEXT_BYTES];
+            let mut shared_secret = [0u8; SHARED_SECRET_BYTES];
+
+            ffi::MLKEM768_encap(
+                ciphertext.as_mut_ptr(),
+                shared_secret.as_mut_ptr(),
+                &self.parsed,
+            );
+
+            (ciphertext, shared_secret)
+        }
+    }
+}
+
+impl fmt::Debug for MlKem768PublicKey {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("MlKem768PublicKey")
+            .field("bytes", &format_args!("[{}]", self.bytes.len()))
+            .finish()
+    }
+}
+
+/// ML-KEM-1024 private key.
+///
+/// Prefer ML-KEM-768 unless you need AES-256 equivalent security.
+/// Caches the expanded key for fast decapsulation.
+struct MlKem1024PrivateKey {
+    seed: MlKemPrivateKeySeed,
+    expanded: ffi::MLKEM1024_private_key,
+}
+
+impl Clone for MlKem1024PrivateKey {
+    fn clone(&self) -> Self {
+        // unwrap is safe: cloning a valid key with a valid seed always succeeds
+        Self::from_seed(&self.seed).unwrap()
+    }
+}
+
+impl MlKem1024PrivateKey {
+    pub const CIPHERTEXT_BYTES: usize = ffi::MLKEM1024_CIPHERTEXT_BYTES as usize;
+
+    /// Generate a new key pair.
+    #[must_use]
+    fn generate() -> (Box<MlKem1024PublicKey>, Box<MlKem1024PrivateKey>) {
+        // SAFETY: all buffers are out parameters, correctly sized
+        unsafe {
+            ffi::init();
+            let mut public_key_bytes: MaybeUninit<[u8; MlKem1024PublicKey::PUBLIC_KEY_BYTES]> =
+                MaybeUninit::uninit();
+            let mut seed: MaybeUninit<MlKemPrivateKeySeed> = MaybeUninit::uninit();
+            let mut expanded: MaybeUninit<ffi::MLKEM1024_private_key> = MaybeUninit::uninit();
+
+            ffi::MLKEM1024_generate_key(
+                public_key_bytes.as_mut_ptr().cast(),
+                seed.as_mut_ptr().cast(),
+                expanded.as_mut_ptr(),
+            );
+
+            let bytes = public_key_bytes.assume_init();
+
+            // Parse the public key bytes to get the parsed struct
+            let mut cbs = cbs_init(&bytes);
+            let mut parsed: MaybeUninit<ffi::MLKEM1024_public_key> = MaybeUninit::uninit();
+            ffi::MLKEM1024_parse_public_key(parsed.as_mut_ptr(), &mut cbs);
+
+            (
+                Box::new(MlKem1024PublicKey {
+                    bytes,
+                    parsed: parsed.assume_init(),
+                }),
+                Box::new(MlKem1024PrivateKey {
+                    seed: seed.assume_init(),
+                    expanded: expanded.assume_init(),
+                }),
+            )
+        }
+    }
+
+    /// Restore private key from seed.
+    fn from_seed(seed: &MlKemPrivateKeySeed) -> Result<Self, ErrorStack> {
+        // SAFETY: seed is 64 bytes, out parameter correctly sized
+        unsafe {
+            ffi::init();
+            let mut expanded: MaybeUninit<ffi::MLKEM1024_private_key> = MaybeUninit::uninit();
+            cvt(ffi::MLKEM1024_private_key_from_seed(
+                expanded.as_mut_ptr(),
+                seed.as_ptr(),
+                seed.len(),
+            ))?;
+            Ok(Self {
+                seed: *seed,
+                expanded: expanded.assume_init(),
+            })
+        }
+    }
+
+    /// Derive the public key.
+    #[cfg(test)]
+    fn public_key(&self) -> Result<MlKem1024PublicKey, ErrorStack> {
+        // SAFETY: expanded key is valid, buffers correctly sized
+        unsafe {
+            ffi::init();
+            let mut parsed: MaybeUninit<ffi::MLKEM1024_public_key> = MaybeUninit::uninit();
+            ffi::MLKEM1024_public_from_private(parsed.as_mut_ptr(), &self.expanded);
+
+            let mut bytes = [0u8; MlKem1024PublicKey::PUBLIC_KEY_BYTES];
+            let mut cbb: MaybeUninit<ffi::CBB> = MaybeUninit::uninit();
+            cvt(ffi::CBB_init_fixed(
+                cbb.as_mut_ptr(),
+                bytes.as_mut_ptr(),
+                bytes.len(),
+            ))?;
+            cvt(ffi::MLKEM1024_marshal_public_key(
+                cbb.as_mut_ptr(),
+                parsed.as_ptr(),
+            ))?;
+
+            Ok(MlKem1024PublicKey {
+                bytes,
+                parsed: parsed.assume_init(),
+            })
+        }
+    }
+
+    /// Decapsulate to get the shared secret.
+    fn decapsulate(&self, ciphertext: &[u8; Self::CIPHERTEXT_BYTES]) -> MlKemSharedSecret {
+        // SAFETY: expanded key is valid, ciphertext is correctly sized
+        unsafe {
+            ffi::init();
+            let mut shared_secret = [0u8; SHARED_SECRET_BYTES];
+
+            ffi::MLKEM1024_decap(
+                shared_secret.as_mut_ptr(),
+                ciphertext.as_ptr(),
+                ciphertext.len(),
+                &self.expanded,
+            );
+
+            shared_secret
+        }
+    }
+}
+
+impl fmt::Debug for MlKem1024PrivateKey {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("MlKem1024PrivateKey")
+            .field("key", &"[redacted]")
+            .finish()
+    }
+}
+
+impl Drop for MlKem1024PrivateKey {
+    fn drop(&mut self) {
+        // SAFETY: pointers and lengths are valid
+        unsafe {
+            ffi::OPENSSL_cleanse(self.seed.as_mut_ptr().cast(), self.seed.len());
+            ffi::OPENSSL_cleanse(
+                self.expanded.opaque.bytes.as_mut_ptr().cast(),
+                self.expanded.opaque.bytes.len(),
+            );
+        }
+    }
+}
+
+/// ML-KEM-1024 public key.
+///
+/// Prefer ML-KEM-768 unless you need AES-256 equivalent security.
+#[derive(Clone)]
+struct MlKem1024PublicKey {
+    bytes: [u8; Self::PUBLIC_KEY_BYTES],
+    parsed: ffi::MLKEM1024_public_key,
+}
+
+impl MlKem1024PublicKey {
+    pub const PUBLIC_KEY_BYTES: usize = ffi::MLKEM1024_PUBLIC_KEY_BYTES as usize;
+
+    /// Parse and validate a serialized public key.
+    ///
+    /// The slice must be [`Self::PUBLIC_KEY_BYTES`] long.
+    fn from_slice(slice: &[u8]) -> Result<Self, ErrorStack> {
+        if slice.len() != Self::PUBLIC_KEY_BYTES {
+            return Err(ErrorStack::internal_error_str("invalid public key length"));
+        }
+
+        // SAFETY: CBS correctly initialized, length already checked
+        unsafe {
+            ffi::init();
+            let mut cbs = cbs_init(slice);
+            let mut parsed: MaybeUninit<ffi::MLKEM1024_public_key> = MaybeUninit::uninit();
+
+            cvt(ffi::MLKEM1024_parse_public_key(
+                parsed.as_mut_ptr(),
+                &mut cbs,
+            ))?;
+            if cbs.len != 0 {
+                return Err(ErrorStack::internal_error_str(
+                    "trailing bytes after public key",
+                ));
+            }
+
+            let mut bytes = [0u8; Self::PUBLIC_KEY_BYTES];
+            bytes.copy_from_slice(slice);
+            Ok(Self {
+                bytes,
+                parsed: parsed.assume_init(),
+            })
+        }
+    }
+
+    /// Encapsulate: returns (ciphertext, shared_secret).
+    fn encapsulate(
+        &self,
+    ) -> (
+        [u8; MlKem1024PrivateKey::CIPHERTEXT_BYTES],
+        [u8; SHARED_SECRET_BYTES],
+    ) {
+        // SAFETY: buffers correctly sized, parsed key is valid
+        unsafe {
+            ffi::init();
+            let mut ciphertext = [0u8; MlKem1024PrivateKey::CIPHERTEXT_BYTES];
+            let mut shared_secret = [0u8; SHARED_SECRET_BYTES];
+
+            ffi::MLKEM1024_encap(
+                ciphertext.as_mut_ptr(),
+                shared_secret.as_mut_ptr(),
+                &self.parsed,
+            );
+
+            (ciphertext, shared_secret)
+        }
+    }
+}
+
+impl fmt::Debug for MlKem1024PublicKey {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("MlKem1024PublicKey")
+            .field("bytes", &format_args!("[{}]", self.bytes.len()))
+            .finish()
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    macro_rules! mlkem_tests {
+        ($name:ident, $priv:ty, $pub:ty, $ct_len:expr) => {
+            mod $name {
+                use super::*;
+
+                #[test]
+                fn roundtrip() {
+                    let (pk, sk) = <$priv>::generate();
+                    let (ct, ss1) = pk.encapsulate();
+                    let ss2 = sk.decapsulate(&ct);
+                    assert_eq!(ss1, ss2);
+                }
+
+                #[test]
+                fn seed_roundtrip() {
+                    let (pk, sk) = <$priv>::generate();
+                    let sk2 = <$priv>::from_seed(&sk.seed).unwrap();
+                    let (ct, ss1) = pk.encapsulate();
+                    let ss2 = sk2.decapsulate(&ct);
+                    assert_eq!(ss1, ss2);
+                }
+
+                #[test]
+                fn derive_pubkey() {
+                    let (pk, sk) = <$priv>::generate();
+                    assert_eq!(pk.bytes, sk.public_key().unwrap().bytes);
+                }
+
+                #[test]
+                fn from_slice_rejects_bad_len() {
+                    assert!(<$pub>::from_slice(&[0u8; 100]).is_err());
+                    assert!(<$pub>::from_slice(&[]).is_err());
+                }
+
+                #[test]
+                fn from_slice_roundtrip() {
+                    let (pk, _) = <$priv>::generate();
+                    let pk2 = <$pub>::from_slice(&pk.bytes).unwrap();
+                    assert_eq!(pk.bytes, pk2.bytes);
+                }
+
+                #[test]
+                fn implicit_rejection() {
+                    let (_, sk) = <$priv>::generate();
+                    let bad_ct = [0x42u8; $ct_len];
+                    // bad ciphertext still "works", just returns deterministic garbage
+                    let ss1 = sk.decapsulate(&bad_ct);
+                    let ss2 = sk.decapsulate(&bad_ct);
+                    assert_eq!(ss1, ss2);
+                }
+
+                #[test]
+                fn debug_redacts_seed() {
+                    let (_, sk) = <$priv>::generate();
+                    let dbg = format!("{:?}", sk);
+                    assert!(dbg.contains("redacted"));
+                }
+            }
+        };
+    }
+
+    mlkem_tests!(mlkem768, MlKem768PrivateKey, MlKem768PublicKey, 1088);
+    mlkem_tests!(mlkem1024, MlKem1024PrivateKey, MlKem1024PublicKey, 1568);
+
+    // Tests for unified API (MlKem struct)
+    mod unified_api {
+        use super::*;
+
+        macro_rules! unified_tests {
+            ($name:ident, $algorithm:expr, $pk_len:expr, $ct_len:expr) => {
+                mod $name {
+                    use super::*;
+
+                    #[test]
+                    fn roundtrip() {
+                        let (pk, sk) = MlKemPrivateKey::generate($algorithm).unwrap();
+                        let (ct, ss1) = pk.encapsulate().unwrap();
+                        let ss2 = sk.decapsulate(&ct).unwrap();
+                        assert_eq!(ss1, ss2);
+                    }
+
+                    #[test]
+                    fn key_sizes() {
+                        assert_eq!($algorithm.public_key_bytes(), $pk_len);
+                        assert_eq!($algorithm.ciphertext_bytes(), $ct_len);
+
+                        let (pk, private_key) = MlKemPrivateKey::generate($algorithm).unwrap();
+                        assert_eq!(pk.as_bytes().len(), $pk_len);
+                        assert_eq!(private_key.seed_bytes().len(), PRIVATE_KEY_SEED_BYTES);
+
+                        let (ct, ss) = pk.encapsulate().unwrap();
+                        assert_eq!(ct.len(), $ct_len);
+                        assert_eq!(ss.len(), SHARED_SECRET_BYTES);
+                    }
+
+                    #[test]
+                    fn invalid_public_key_length() {
+                        let result = MlKemPublicKey::from_slice($algorithm, &[0u8; 100]);
+                        assert!(result.is_err());
+                    }
+
+                    #[test]
+                    fn invalid_ciphertext_length() {
+                        let (_, sk) = MlKemPrivateKey::generate($algorithm).unwrap();
+                        let result = sk.decapsulate(&[0u8; 100]);
+                        assert!(result.is_err());
+                    }
+                }
+            };
+        }
+
+        unified_tests!(mlkem768, Algorithm::MlKem768, 1184, 1088);
+        unified_tests!(mlkem1024, Algorithm::MlKem1024, 1568, 1568);
+
+        #[test]
+        fn params_constants() {
+            assert_eq!(Algorithm::MlKem768.public_key_bytes(), 1184);
+            assert_eq!(Algorithm::MlKem768.ciphertext_bytes(), 1088);
+            assert_eq!(Algorithm::MlKem1024.public_key_bytes(), 1568);
+            assert_eq!(Algorithm::MlKem1024.ciphertext_bytes(), 1568);
+        }
+    }
+}
diff --git a/boring/src/nid.rs b/boring/src/nid.rs
index 347b30f7..15cfe4eb 100644
--- a/boring/src/nid.rs
+++ b/boring/src/nid.rs
@@ -1,6 +1,6 @@
 //! A collection of numerical identifiers for OpenSSL objects.
 use crate::ffi;
-use libc::{c_char, c_int};
+use libc::c_int;
 use openssl_macros::corresponds;
 
 use std::ffi::CStr;
@@ -87,7 +87,7 @@ impl Nid {
     #[allow(clippy::trivially_copy_pass_by_ref)]
     pub fn long_name(&self) -> Result<&'static str, ErrorStack> {
         unsafe {
-            let nameptr = cvt_p(ffi::OBJ_nid2ln(self.0) as *mut c_char)?;
+            let nameptr = cvt_p(ffi::OBJ_nid2ln(self.0).cast_mut())?;
             CStr::from_ptr(nameptr)
                 .to_str()
                 .map_err(ErrorStack::internal_error)
@@ -99,7 +99,7 @@ impl Nid {
     #[allow(clippy::trivially_copy_pass_by_ref)]
     pub fn short_name(&self) -> Result<&'static str, ErrorStack> {
         unsafe {
-            let nameptr = cvt_p(ffi::OBJ_nid2sn(self.0) as *mut c_char)?;
+            let nameptr = cvt_p(ffi::OBJ_nid2sn(self.0).cast_mut())?;
             CStr::from_ptr(nameptr)
                 .to_str()
                 .map_err(ErrorStack::internal_error)
diff --git a/boring/src/pkcs12.rs b/boring/src/pkcs12.rs
index e8fb7c12..bb851421 100644
--- a/boring/src/pkcs12.rs
+++ b/boring/src/pkcs12.rs
@@ -180,8 +180,8 @@ impl Pkcs12Builder {
             let keytype = 0;
 
             cvt_p(ffi::PKCS12_create(
-                pass.as_ptr() as *const _ as *mut _,
-                friendly_name.as_ptr() as *const _ as *mut _,
+                pass.as_ptr(),
+                friendly_name.as_ptr(),
                 pkey,
                 cert,
                 ca,
diff --git a/boring/src/pkcs5.rs b/boring/src/pkcs5.rs
index 91684661..1e1665bc 100644
--- a/boring/src/pkcs5.rs
+++ b/boring/src/pkcs5.rs
@@ -1,11 +1,11 @@
 use crate::ffi;
-use libc::{c_int, c_uint};
+use std::ffi::c_int;
 use std::ptr;
 
-use crate::cvt;
 use crate::error::ErrorStack;
 use crate::hash::MessageDigest;
 use crate::symm::Cipher;
+use crate::{cvt, cvt_nz, try_int};
 
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub struct KeyIvPair {
@@ -49,7 +49,7 @@ pub fn bytes_to_key(
         let cipher = cipher.as_ptr();
         let digest = digest.as_ptr();
 
-        let len = cvt(ffi::EVP_BytesToKey(
+        let len = cvt_nz(ffi::EVP_BytesToKey(
             cipher,
             digest,
             salt_ptr,
@@ -60,7 +60,7 @@ pub fn bytes_to_key(
             ptr::null_mut(),
         ))?;
 
-        let mut key = vec![0; len as usize];
+        let mut key = vec![0; len.get()];
         let iv_ptr = iv
             .as_mut()
             .map(|v| v.as_mut_ptr())
@@ -90,22 +90,18 @@ pub fn pbkdf2_hmac(
     key: &mut [u8],
 ) -> Result<(), ErrorStack> {
     unsafe {
-        assert!(pass.len() <= c_int::MAX as usize);
-        assert!(salt.len() <= c_int::MAX as usize);
-        assert!(key.len() <= c_int::MAX as usize);
-
         ffi::init();
+
         cvt(ffi::PKCS5_PBKDF2_HMAC(
-            pass.as_ptr() as *const _,
+            pass.as_ptr().cast(),
             pass.len(),
             salt.as_ptr(),
             salt.len(),
-            iter as c_uint,
+            try_int(iter)?,
             hash.as_ptr(),
             key.len(),
             key.as_mut_ptr(),
         ))
-        .map(|_| ())
     }
 }
 
@@ -122,18 +118,17 @@ pub fn scrypt(
     unsafe {
         ffi::init();
         cvt(ffi::EVP_PBE_scrypt(
-            pass.as_ptr() as *const _,
+            pass.as_ptr().cast(),
             pass.len(),
-            salt.as_ptr() as *const _,
+            salt.as_ptr().cast(),
             salt.len(),
             n,
             r,
             p,
             maxmem,
-            key.as_mut_ptr() as *mut _,
+            key.as_mut_ptr(),
             key.len(),
         ))
-        .map(|_| ())
     }
 }
 
diff --git a/boring/src/pkey.rs b/boring/src/pkey.rs
index 9245f5b6..0ab9c528 100644
--- a/boring/src/pkey.rs
+++ b/boring/src/pkey.rs
@@ -40,7 +40,6 @@
 //! println!("{:?}", str::from_utf8(pub_key.as_slice()).unwrap());
 //! ```
 
-use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
 use libc::{c_int, c_long};
 use openssl_macros::corresponds;
@@ -54,7 +53,9 @@ use crate::dh::Dh;
 use crate::dsa::Dsa;
 use crate::ec::EcKey;
 use crate::error::ErrorStack;
+use crate::ffi;
 use crate::rsa::Rsa;
+use crate::try_int;
 use crate::util::{invoke_passwd_cb, CallbackState};
 use crate::{cvt, cvt_0i, cvt_p};
 
@@ -361,7 +362,7 @@ impl<T> PKey<T> {
             cvt(ffi::EVP_PKEY_assign(
                 pkey.0,
                 ffi::EVP_PKEY_RSA,
-                rsa.as_ptr() as *mut _,
+                rsa.as_ptr().cast(),
             ))?;
             mem::forget(rsa);
             Ok(pkey)
@@ -377,7 +378,7 @@ impl<T> PKey<T> {
             cvt(ffi::EVP_PKEY_assign(
                 pkey.0,
                 ffi::EVP_PKEY_EC,
-                ec_key.as_ptr() as *mut _,
+                ec_key.as_ptr().cast(),
             ))?;
             mem::forget(ec_key);
             Ok(pkey)
@@ -455,7 +456,7 @@ impl PKey<Private> {
                 bio.as_ptr(),
                 ptr::null_mut(),
                 Some(invoke_passwd_cb::<F>),
-                &mut cb as *mut _ as *mut _,
+                std::ptr::addr_of_mut!(cb).cast(),
             ))
             .map(|p| PKey::from_ptr(p))
         }
@@ -479,7 +480,7 @@ impl PKey<Private> {
                 bio.as_ptr(),
                 ptr::null_mut(),
                 None,
-                passphrase.as_ptr() as *const _ as *mut _,
+                passphrase.as_ptr().cast_mut().cast(),
             ))
             .map(|p| PKey::from_ptr(p))
         }
diff --git a/boring/src/rand.rs b/boring/src/rand.rs
index e5b843e0..e9a69e46 100644
--- a/boring/src/rand.rs
+++ b/boring/src/rand.rs
@@ -36,7 +36,7 @@ pub fn rand_bytes(buf: &mut [u8]) -> Result<(), ErrorStack> {
     unsafe {
         ffi::init();
         assert!(buf.len() <= c_int::MAX as usize);
-        cvt(ffi::RAND_bytes(buf.as_mut_ptr(), buf.len())).map(|_| ())
+        cvt(ffi::RAND_bytes(buf.as_mut_ptr(), buf.len()))
     }
 }
 
diff --git a/boring/src/rsa.rs b/boring/src/rsa.rs
index ff47e71b..413048cc 100644
--- a/boring/src/rsa.rs
+++ b/boring/src/rsa.rs
@@ -23,7 +23,6 @@
 //! let mut buf = vec![0; rsa.size() as usize];
 //! let encrypted_len = rsa.public_encrypt(data, &mut buf, Padding::PKCS1).unwrap();
 //! ```
-use crate::ffi;
 use foreign_types::{ForeignType, ForeignTypeRef};
 use libc::c_int;
 use openssl_macros::corresponds;
@@ -33,7 +32,9 @@ use std::ptr;
 
 use crate::bn::{BigNum, BigNumRef};
 use crate::error::ErrorStack;
+use crate::ffi;
 use crate::pkey::{HasPrivate, HasPublic, Private, Public};
+use crate::try_int;
 use crate::{cvt, cvt_n, cvt_p};
 
 pub const EVP_PKEY_OP_SIGN: c_int = 1 << 3;
@@ -194,7 +195,7 @@ where
         unsafe {
             let mut d = ptr::null();
             RSA_get0_key(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut d);
-            BigNumRef::from_ptr(d as *mut _)
+            BigNumRef::from_ptr(d.cast_mut())
         }
     }
 
@@ -208,7 +209,7 @@ where
             if p.is_null() {
                 None
             } else {
-                Some(BigNumRef::from_ptr(p as *mut _))
+                Some(BigNumRef::from_ptr(p.cast_mut()))
             }
         }
     }
@@ -223,7 +224,7 @@ where
             if q.is_null() {
                 None
             } else {
-                Some(BigNumRef::from_ptr(q as *mut _))
+                Some(BigNumRef::from_ptr(q.cast_mut()))
             }
         }
     }
@@ -238,7 +239,7 @@ where
             if dp.is_null() {
                 None
             } else {
-                Some(BigNumRef::from_ptr(dp as *mut _))
+                Some(BigNumRef::from_ptr(dp.cast_mut()))
             }
         }
     }
@@ -253,7 +254,7 @@ where
             if dq.is_null() {
                 None
             } else {
-                Some(BigNumRef::from_ptr(dq as *mut _))
+                Some(BigNumRef::from_ptr(dq.cast_mut()))
             }
         }
     }
@@ -268,7 +269,7 @@ where
             if qi.is_null() {
                 None
             } else {
-                Some(BigNumRef::from_ptr(qi as *mut _))
+                Some(BigNumRef::from_ptr(qi.cast_mut()))
             }
         }
     }
@@ -391,7 +392,7 @@ where
         unsafe {
             let mut n = ptr::null();
             RSA_get0_key(self.as_ptr(), &mut n, ptr::null_mut(), ptr::null_mut());
-            BigNumRef::from_ptr(n as *mut _)
+            BigNumRef::from_ptr(n.cast_mut())
         }
     }
 
@@ -402,7 +403,7 @@ where
         unsafe {
             let mut e = ptr::null();
             RSA_get0_key(self.as_ptr(), ptr::null_mut(), &mut e, ptr::null_mut());
-            BigNumRef::from_ptr(e as *mut _)
+            BigNumRef::from_ptr(e.cast_mut())
         }
     }
 }
diff --git a/boring/src/sha.rs b/boring/src/sha.rs
index f0f9b15c..dd067185 100644
--- a/boring/src/sha.rs
+++ b/boring/src/sha.rs
@@ -54,7 +54,6 @@ use std::mem::MaybeUninit;
 /// SHA1 is known to be insecure - it should not be used unless required for
 /// compatibility with existing systems.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha1(data: &[u8]) -> [u8; 20] {
     unsafe {
@@ -66,7 +65,6 @@ pub fn sha1(data: &[u8]) -> [u8; 20] {
 
 /// Computes the SHA224 hash of some data.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha224(data: &[u8]) -> [u8; 28] {
     unsafe {
@@ -78,7 +76,6 @@ pub fn sha224(data: &[u8]) -> [u8; 28] {
 
 /// Computes the SHA256 hash of some data.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha256(data: &[u8]) -> [u8; 32] {
     unsafe {
@@ -90,7 +87,6 @@ pub fn sha256(data: &[u8]) -> [u8; 32] {
 
 /// Computes the SHA384 hash of some data.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha384(data: &[u8]) -> [u8; 48] {
     unsafe {
@@ -102,7 +98,6 @@ pub fn sha384(data: &[u8]) -> [u8; 48] {
 
 /// Computes the SHA512 hash of some data.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha512(data: &[u8]) -> [u8; 64] {
     unsafe {
@@ -114,7 +109,6 @@ pub fn sha512(data: &[u8]) -> [u8; 64] {
 
 /// Computes the SHA512-256 hash of some data.
 #[inline]
-#[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
 #[must_use]
 pub fn sha512_256(data: &[u8]) -> [u8; 32] {
     unsafe {
@@ -143,7 +137,6 @@ impl Default for Sha1 {
 impl Sha1 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha1 {
         unsafe {
@@ -159,13 +152,12 @@ impl Sha1 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA1_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA1_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 20] {
         unsafe {
@@ -190,7 +182,6 @@ impl Default for Sha224 {
 impl Sha224 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha224 {
         unsafe {
@@ -206,13 +197,12 @@ impl Sha224 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA224_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA224_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 28] {
         unsafe {
@@ -237,7 +227,6 @@ impl Default for Sha256 {
 impl Sha256 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha256 {
         unsafe {
@@ -253,13 +242,12 @@ impl Sha256 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA256_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA256_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 32] {
         unsafe {
@@ -284,7 +272,6 @@ impl Default for Sha384 {
 impl Sha384 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha384 {
         unsafe {
@@ -300,13 +287,12 @@ impl Sha384 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA384_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA384_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 48] {
         unsafe {
@@ -331,7 +317,6 @@ impl Default for Sha512 {
 impl Sha512 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha512 {
         unsafe {
@@ -347,13 +332,12 @@ impl Sha512 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA512_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA512_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 64] {
         unsafe {
@@ -378,7 +362,6 @@ impl Default for Sha512_256 {
 impl Sha512_256 {
     /// Creates a new hasher.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn new() -> Sha512_256 {
         unsafe {
@@ -394,13 +377,12 @@ impl Sha512_256 {
     #[inline]
     pub fn update(&mut self, buf: &[u8]) {
         unsafe {
-            ffi::SHA512_256_Update(&mut self.0, buf.as_ptr() as *const c_void, buf.len());
+            ffi::SHA512_256_Update(&mut self.0, buf.as_ptr().cast::<c_void>(), buf.len());
         }
     }
 
     /// Returns the hash of the data.
     #[inline]
-    #[allow(deprecated)] // https://github.com/rust-lang/rust/issues/63566
     #[must_use]
     pub fn finish(mut self) -> [u8; 32] {
         unsafe {
diff --git a/boring/src/sign.rs b/boring/src/sign.rs
index b87e6010..eea911e6 100644
--- a/boring/src/sign.rs
+++ b/boring/src/sign.rs
@@ -174,7 +174,6 @@ impl<'a> Signer<'a> {
                 self.pctx,
                 padding.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -188,7 +187,6 @@ impl<'a> Signer<'a> {
                 self.pctx,
                 len.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -200,9 +198,8 @@ impl<'a> Signer<'a> {
         unsafe {
             cvt(ffi::EVP_PKEY_CTX_set_rsa_mgf1_md(
                 self.pctx,
-                md.as_ptr() as *mut _,
+                md.as_ptr().cast_mut(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -215,10 +212,9 @@ impl<'a> Signer<'a> {
         unsafe {
             cvt(ffi::EVP_DigestUpdate(
                 self.md_ctx,
-                buf.as_ptr() as *const _,
+                buf.as_ptr().cast(),
                 buf.len(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -255,7 +251,7 @@ impl<'a> Signer<'a> {
             let mut len = buf.len();
             cvt(ffi::EVP_DigestSignFinal(
                 self.md_ctx,
-                buf.as_mut_ptr() as *mut _,
+                buf.as_mut_ptr().cast(),
                 &mut len,
             ))?;
             Ok(len)
@@ -290,9 +286,9 @@ impl<'a> Signer<'a> {
             let mut sig_len = sig_buf.len();
             cvt(ffi::EVP_DigestSign(
                 self.md_ctx,
-                sig_buf.as_mut_ptr() as *mut _,
+                sig_buf.as_mut_ptr(),
                 &mut sig_len,
-                data_buf.as_ptr() as *const _,
+                data_buf.as_ptr(),
                 data_buf.len(),
             ))?;
             Ok(sig_len)
@@ -421,7 +417,6 @@ impl<'a> Verifier<'a> {
                 self.pctx,
                 padding.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -435,7 +430,6 @@ impl<'a> Verifier<'a> {
                 self.pctx,
                 len.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -447,9 +441,8 @@ impl<'a> Verifier<'a> {
         unsafe {
             cvt(ffi::EVP_PKEY_CTX_set_rsa_mgf1_md(
                 self.pctx,
-                md.as_ptr() as *mut _,
+                md.as_ptr().cast_mut(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -462,10 +455,9 @@ impl<'a> Verifier<'a> {
         unsafe {
             cvt(ffi::EVP_DigestUpdate(
                 self.md_ctx,
-                buf.as_ptr() as *const _,
+                buf.as_ptr().cast(),
                 buf.len(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -474,7 +466,7 @@ impl<'a> Verifier<'a> {
     pub fn verify(&self, signature: &[u8]) -> Result<bool, ErrorStack> {
         unsafe {
             let r =
-                EVP_DigestVerifyFinal(self.md_ctx, signature.as_ptr() as *mut _, signature.len());
+                EVP_DigestVerifyFinal(self.md_ctx, signature.as_ptr().cast_mut(), signature.len());
             match r {
                 1 => Ok(true),
                 0 => {
@@ -492,9 +484,9 @@ impl<'a> Verifier<'a> {
         unsafe {
             let r = ffi::EVP_DigestVerify(
                 self.md_ctx,
-                signature.as_ptr() as *const _,
+                signature.as_ptr().cast(),
                 signature.len(),
-                buf.as_ptr() as *const _,
+                buf.as_ptr().cast(),
                 buf.len(),
             );
             match r {
diff --git a/boring/src/srtp.rs b/boring/src/srtp.rs
index 8d23b722..7dffc436 100644
--- a/boring/src/srtp.rs
+++ b/boring/src/srtp.rs
@@ -27,7 +27,7 @@ impl SrtpProtectionProfileRef {
 
     #[must_use]
     pub fn name(&self) -> &'static str {
-        unsafe { CStr::from_ptr((*self.as_ptr()).name as *const _) }
+        unsafe { CStr::from_ptr((*self.as_ptr()).name.cast()) }
             .to_str()
             .expect("should be UTF-8")
     }
diff --git a/boring/src/ssl/async_callbacks.rs b/boring/src/ssl/async_callbacks.rs
index 4ab18d11..ad9683a0 100644
--- a/boring/src/ssl/async_callbacks.rs
+++ b/boring/src/ssl/async_callbacks.rs
@@ -4,7 +4,9 @@ use super::{
     Ssl, SslAlert, SslContextBuilder, SslRef, SslSession, SslSignatureAlgorithm, SslVerifyError,
     SslVerifyMode,
 };
+use crate::error::ErrorStack;
 use crate::ex_data::Index;
+use crate::ssl::SslCredentialBuilder;
 use std::convert::identity;
 use std::future::Future;
 use std::pin::Pin;
@@ -171,6 +173,21 @@ impl SslContextBuilder {
     }
 }
 
+impl SslCredentialBuilder {
+    /// Configures a custom private key method on the context.
+    ///
+    /// A task waker must be set on `Ssl` values associated with the resulting
+    /// `SslContext` with [`SslRef::set_task_waker`].
+    ///
+    /// See [`AsyncPrivateKeyMethod`] for more details.
+    pub fn set_async_private_key_method(
+        &mut self,
+        method: impl AsyncPrivateKeyMethod,
+    ) -> Result<(), ErrorStack> {
+        self.set_private_key_method(AsyncPrivateKeyMethodBridge(Box::new(method)))
+    }
+}
+
 impl SslRef {
     pub fn set_async_custom_verify_callback<F>(&mut self, mode: SslVerifyMode, callback: F)
     where
diff --git a/boring/src/ssl/bio.rs b/boring/src/ssl/bio.rs
index e700dbe3..3bae8a79 100644
--- a/boring/src/ssl/bio.rs
+++ b/boring/src/ssl/bio.rs
@@ -44,7 +44,7 @@ pub fn new<S: Read + Write>(stream: S) -> Result<(*mut BIO, BioMethod), ErrorSta
 
     unsafe {
         let bio = cvt_p(BIO_new(method.0.get()))?;
-        BIO_set_data(bio, Box::into_raw(state) as *mut _);
+        BIO_set_data(bio, Box::into_raw(state).cast());
         BIO_set_init(bio, 1);
 
         Ok((bio, method))
@@ -76,7 +76,7 @@ pub unsafe extern "C" fn take_stream<S>(bio: *mut BIO) -> S {
 
     assert!(!data.is_null());
 
-    let state = Box::<StreamState<S>>::from_raw(data as *mut _);
+    let state = Box::<StreamState<S>>::from_raw(data.cast());
 
     BIO_set_data(bio, ptr::null_mut());
 
@@ -91,7 +91,7 @@ pub unsafe fn set_dtls_mtu_size<S>(bio: *mut BIO, mtu_size: usize) {
 }
 
 unsafe fn state<'a, S: 'a>(bio: *mut BIO) -> &'a mut StreamState<S> {
-    let data = BIO_get_data(bio) as *mut StreamState<S>;
+    let data = BIO_get_data(bio).cast::<StreamState<S>>();
 
     assert!(!data.is_null());
 
@@ -101,8 +101,12 @@ unsafe fn state<'a, S: 'a>(bio: *mut BIO) -> &'a mut StreamState<S> {
 unsafe extern "C" fn bwrite<S: Write>(bio: *mut BIO, buf: *const c_char, len: c_int) -> c_int {
     BIO_clear_retry_flags(bio);
 
+    let Ok(len) = usize::try_from(len) else {
+        return -1;
+    };
+
     let state = state::<S>(bio);
-    let buf = slice::from_raw_parts(buf as *const _, len as usize);
+    let buf = slice::from_raw_parts(buf.cast(), len);
 
     match catch_unwind(AssertUnwindSafe(|| state.stream.write(buf))) {
         Ok(Ok(len)) => len as c_int,
@@ -123,8 +127,12 @@ unsafe extern "C" fn bwrite<S: Write>(bio: *mut BIO, buf: *const c_char, len: c_
 unsafe extern "C" fn bread<S: Read>(bio: *mut BIO, buf: *mut c_char, len: c_int) -> c_int {
     BIO_clear_retry_flags(bio);
 
+    let Ok(len) = usize::try_from(len) else {
+        return -1;
+    };
+
     let state = state::<S>(bio);
-    let buf = slice::from_raw_parts_mut(buf as *mut _, len as usize);
+    let buf = slice::from_raw_parts_mut(buf.cast(), len);
 
     match catch_unwind(AssertUnwindSafe(|| state.stream.read(buf))) {
         Ok(Ok(len)) => len as c_int,
@@ -163,9 +171,13 @@ unsafe extern "C" fn ctrl<S: Write>(
     let state = state::<S>(bio);
 
     if cmd == BIO_CTRL_FLUSH {
+        BIO_clear_retry_flags(bio);
         match catch_unwind(AssertUnwindSafe(|| state.stream.flush())) {
             Ok(Ok(())) => 1,
             Ok(Err(err)) => {
+                if retriable_error(&err) {
+                    BIO_set_retry_write(bio);
+                }
                 state.error = Some(err);
                 0
             }
@@ -197,7 +209,7 @@ unsafe extern "C" fn destroy<S>(bio: *mut BIO) -> c_int {
     let data = BIO_get_data(bio);
 
     if !data.is_null() {
-        drop(Box::<StreamState<S>>::from_raw(data as *mut _));
+        drop(Box::<StreamState<S>>::from_raw(data.cast()));
         BIO_set_data(bio, ptr::null_mut());
     }
 
diff --git a/boring/src/ssl/callbacks.rs b/boring/src/ssl/callbacks.rs
index f08409b3..41c08c6b 100644
--- a/boring/src/ssl/callbacks.rs
+++ b/boring/src/ssl/callbacks.rs
@@ -41,7 +41,7 @@ where
 
     // SAFETY: The callback won't outlive the context it's associated with
     // because there is no `X509StoreContextRef::ssl_mut(&mut self)` method.
-    let verify = unsafe { &*(verify as *const F) };
+    let verify = unsafe { &*std::ptr::from_ref::<F>(verify) };
 
     c_int::from(verify(preverify_ok != 0, ctx))
 }
@@ -90,7 +90,7 @@ where
     // SAFETY: The callback won't outlive the context it's associated with
     // because there is no way to get a mutable reference to the `SslContext`,
     // so the callback can't replace itself.
-    let verify = unsafe { &*(verify as *const F) };
+    let verify = unsafe { &*std::ptr::from_ref::<F>(verify) };
 
     c_int::from(verify(ctx))
 }
@@ -160,7 +160,7 @@ where
 
     // Give the callback mutable slices into which it can write the identity and psk.
     let identity_sl =
-        unsafe { slice::from_raw_parts_mut(identity as *mut u8, max_identity_len as usize) };
+        unsafe { slice::from_raw_parts_mut(identity.cast::<u8>(), max_identity_len as usize) };
     let psk_sl = unsafe { slice::from_raw_parts_mut(psk, max_psk_len as usize) };
 
     let ssl_context = ssl.ssl_context().to_owned();
@@ -358,7 +358,7 @@ where
 
     match callback(ssl, protos) {
         Ok(proto) => {
-            *out = proto.as_ptr() as *const c_uchar;
+            *out = proto.as_ptr();
             *outlen = proto.len() as c_uchar;
 
             ffi::SSL_TLSEXT_ERR_OK
@@ -442,7 +442,7 @@ where
     // SAFETY: We can make `callback` outlive `ssl` because it is a callback
     // stored in the session context set in `Ssl::new` so it is always
     // guaranteed to outlive the lifetime of this function's scope.
-    let callback = unsafe { &*(callback as *const F) };
+    let callback = unsafe { &*std::ptr::from_ref::<F>(callback) };
 
     callback(ssl, session);
 
@@ -495,7 +495,7 @@ where
     // SAFETY: We can make `callback` outlive `ssl` because it is a callback
     // stored in the session context set in `Ssl::new` so it is always
     // guaranteed to outlive the lifetime of this function's scope.
-    let callback = unsafe { &*(callback as *const F) };
+    let callback = unsafe { &*std::ptr::from_ref::<F>(callback) };
 
     match callback(ssl, data) {
         Ok(Some(session)) => {
@@ -515,7 +515,7 @@ where
     F: Fn(&SslRef, &str) + 'static + Sync + Send,
 {
     // SAFETY: boring provides valid inputs.
-    let ssl = unsafe { SslRef::from_ptr(ssl as *mut _) };
+    let ssl = unsafe { SslRef::from_ptr(ssl.cast_mut()) };
     let line = unsafe { CStr::from_ptr(line).to_string_lossy() };
 
     let callback = ssl
@@ -625,7 +625,7 @@ pub(super) unsafe extern "C" fn raw_info_callback<F>(
 {
     // Due to FFI signature requirements we have to pass a *const SSL into this function, but
     // foreign-types requires a *mut SSL to get the Rust SslRef
-    let mut_ref = ssl as *mut ffi::SSL;
+    let mut_ref = ssl.cast_mut();
 
     // SAFETY: boring provides valid inputs.
     let ssl = unsafe { SslRef::from_ptr(mut_ref) };
diff --git a/boring/src/ssl/connector.rs b/boring/src/ssl/connector.rs
index 832bd73e..88089978 100644
--- a/boring/src/ssl/connector.rs
+++ b/boring/src/ssl/connector.rs
@@ -1,16 +1,13 @@
 use std::io::{Read, Write};
 use std::ops::{Deref, DerefMut};
 
-use foreign_types::ForeignTypeRef;
-use openssl_macros::corresponds;
-
 use crate::dh::Dh;
 use crate::error::ErrorStack;
 use crate::ssl::{
     HandshakeError, Ssl, SslContext, SslContextBuilder, SslContextRef, SslMethod, SslMode,
     SslOptions, SslRef, SslStream, SslVerifyMode,
 };
-use crate::{cvt, version};
+use crate::version;
 use std::net::IpAddr;
 
 use super::MidHandshakeSslStream;
@@ -26,19 +23,9 @@ ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
 -----END DH PARAMETERS-----
 ";
 
-enum ContextType {
-    WithMethod(SslMethod),
-    #[cfg(feature = "rpk")]
-    Rpk,
-}
-
 #[allow(clippy::inconsistent_digit_grouping)]
-fn ctx(ty: ContextType) -> Result<SslContextBuilder, ErrorStack> {
-    let mut ctx = match ty {
-        ContextType::WithMethod(method) => SslContextBuilder::new(method),
-        #[cfg(feature = "rpk")]
-        ContextType::Rpk => SslContextBuilder::new_rpk(),
-    }?;
+fn ctx(method: SslMethod) -> Result<SslContextBuilder, ErrorStack> {
+    let mut ctx = SslContextBuilder::new(method)?;
 
     let mut opts = SslOptions::ALL
         | SslOptions::NO_COMPRESSION
@@ -80,7 +67,7 @@ impl SslConnector {
     ///
     /// The default configuration is subject to change, and is currently derived from Python.
     pub fn builder(method: SslMethod) -> Result<SslConnectorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::WithMethod(method))?;
+        let mut ctx = ctx(method)?;
         ctx.set_default_verify_paths()?;
         ctx.set_cipher_list(
             "DEFAULT:!aNULL:!eNULL:!MD5:!3DES:!DES:!RC4:!IDEA:!SEED:!aDSS:!SRP:!PSK",
@@ -90,29 +77,6 @@ impl SslConnector {
         Ok(SslConnectorBuilder(ctx))
     }
 
-    /// Creates a new builder for TLS connections with no verification.
-    ///
-    /// This is useful for testing and other purposes where you want to skip verification.
-    pub fn no_default_verify_builder(method: SslMethod) -> Result<SslConnectorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::WithMethod(method))?;
-        ctx.set_cipher_list(
-            "DEFAULT:!aNULL:!eNULL:!MD5:!3DES:!DES:!RC4:!IDEA:!SEED:!aDSS:!SRP:!PSK",
-        )?;
-
-        Ok(SslConnectorBuilder(ctx))
-    }
-
-    /// Creates a new builder for TLS connections with raw public key.
-    #[cfg(feature = "rpk")]
-    pub fn rpk_builder() -> Result<SslConnectorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::Rpk)?;
-        ctx.set_cipher_list(
-            "DEFAULT:!aNULL:!eNULL:!MD5:!3DES:!DES:!RC4:!IDEA:!SEED:!aDSS:!SRP:!PSK",
-        )?;
-
-        Ok(SslConnectorBuilder(ctx))
-    }
-
     /// Initiates a client-side TLS session on a stream.
     ///
     /// The domain is used for SNI and hostname verification.
@@ -239,13 +203,7 @@ impl ConnectConfiguration {
             self.ssl.set_hostname(domain)?;
         }
 
-        #[cfg(feature = "rpk")]
-        let verify_hostname = !self.ssl.ssl_context().is_rpk() && self.verify_hostname;
-
-        #[cfg(not(feature = "rpk"))]
-        let verify_hostname = self.verify_hostname;
-
-        if verify_hostname {
+        if self.verify_hostname {
             setup_verify_hostname(&mut self.ssl, domain)?;
         }
 
@@ -285,71 +243,7 @@ impl ConnectConfiguration {
     }
 }
 
-impl ConnectConfiguration {
-    /// A builder-style version of `set_enable_ech_grease`
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_set_enable_ech_grease)]
-    pub fn enable_ech_grease(mut self, enable: bool) -> Self {
-        self.set_enable_ech_grease(enable);
-        self
-    }
-
-    /// Enables or disables ECH grease.
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_set_enable_ech_grease)]
-    pub fn set_enable_ech_grease(&mut self, enable: bool) {
-        unsafe { ffi::SSL_set_enable_ech_grease(self.as_ptr(), enable as _) }
-    }
-
-    /// A builder-style version of `set_aes_hw_override`
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_set_aes_hw_override)]
-    pub fn aes_hw_override(mut self, enable: bool) -> Self {
-        self.set_aes_hw_override(enable);
-        self
-    }
-
-    /// Sets whether the aes hardware override should be enabled.
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_set_aes_hw_override)]
-    pub fn set_aes_hw_override(&mut self, enable: bool) {
-        unsafe { ffi::SSL_set_aes_hw_override(self.as_ptr(), enable as _) }
-    }
-
-    /// A builder-style version of `add_application_settings`
-    #[corresponds(SSL_add_application_settings)]
-    pub fn application_settings(mut self, alps: &[u8]) -> Result<Self, ErrorStack> {
-        self.add_application_settings(alps).map(|_| self)
-    }
-
-    /// Sets application settings flag for ALPS (Application-Layer Protocol Negotiation).
-    #[corresponds(SSL_add_application_settings)]
-    pub fn add_application_settings(&mut self, alps: &[u8]) -> Result<(), ErrorStack> {
-        unsafe {
-            cvt(ffi::SSL_add_application_settings(
-                self.as_ptr(),
-                alps.as_ptr(),
-                alps.len(),
-                std::ptr::null(),
-                0,
-            ))
-            .map(|_| ())
-        }
-    }
-
-    /// A builder-style version of `set_alps_use_new_codepoint`
-    #[corresponds(SSL_set_alps_use_new_codepoint)]
-    pub fn alps_use_new_codepoint(mut self, use_new: bool) -> Self {
-        self.set_alps_use_new_codepoint(use_new);
-        self
-    }
-
-    /// Sets the ALPS use new codepoint flag.
-    #[corresponds(SSL_set_alps_use_new_codepoint)]
-    pub fn set_alps_use_new_codepoint(&mut self, use_new: bool) {
-        unsafe { ffi::SSL_set_alps_use_new_codepoint(self.as_ptr(), use_new as _) }
-    }
-}
+// TODO: INSERT HERE
 
 impl Deref for ConnectConfiguration {
     type Target = SslRef;
@@ -373,21 +267,6 @@ impl DerefMut for ConnectConfiguration {
 pub struct SslAcceptor(SslContext);
 
 impl SslAcceptor {
-    /// Creates a new builder configured to connect to clients that support Raw Public Keys.
-    #[cfg(feature = "rpk")]
-    pub fn rpk() -> Result<SslAcceptorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::Rpk)?;
-        ctx.set_options(SslOptions::NO_TLSV1 | SslOptions::NO_TLSV1_1);
-        let dh = Dh::params_from_pem(FFDHE_2048.as_bytes())?;
-        ctx.set_tmp_dh(&dh)?;
-        ctx.set_cipher_list(
-            "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:\
-             ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:\
-             DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384"
-        )?;
-        Ok(SslAcceptorBuilder(ctx))
-    }
-
     /// Creates a new builder configured to connect to non-legacy clients. This should generally be
     /// considered a reasonable default choice.
     ///
@@ -396,7 +275,7 @@ impl SslAcceptor {
     ///
     /// [docs]: https://wiki.mozilla.org/Security/Server_Side_TLS
     pub fn mozilla_intermediate_v5(method: SslMethod) -> Result<SslAcceptorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::WithMethod(method))?;
+        let mut ctx = ctx(method)?;
         ctx.set_options(SslOptions::NO_TLSV1 | SslOptions::NO_TLSV1_1);
         let dh = Dh::params_from_pem(FFDHE_2048.as_bytes())?;
         ctx.set_tmp_dh(&dh)?;
@@ -417,7 +296,7 @@ impl SslAcceptor {
     /// [docs]: https://wiki.mozilla.org/Security/Server_Side_TLS
     // FIXME remove in next major version
     pub fn mozilla_intermediate(method: SslMethod) -> Result<SslAcceptorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::WithMethod(method))?;
+        let mut ctx = ctx(method)?;
         ctx.set_options(SslOptions::CIPHER_SERVER_PREFERENCE);
         ctx.set_options(SslOptions::NO_TLSV1_3);
         let dh = Dh::params_from_pem(FFDHE_2048.as_bytes())?;
@@ -443,7 +322,7 @@ impl SslAcceptor {
     /// [docs]: https://wiki.mozilla.org/Security/Server_Side_TLS
     // FIXME remove in next major version
     pub fn mozilla_modern(method: SslMethod) -> Result<SslAcceptorBuilder, ErrorStack> {
-        let mut ctx = ctx(ContextType::WithMethod(method))?;
+        let mut ctx = ctx(method)?;
         ctx.set_options(
             SslOptions::CIPHER_SERVER_PREFERENCE | SslOptions::NO_TLSV1 | SslOptions::NO_TLSV1_1,
         );
diff --git a/boring/src/ssl/credential.rs b/boring/src/ssl/credential.rs
new file mode 100644
index 00000000..df8fb0c3
--- /dev/null
+++ b/boring/src/ssl/credential.rs
@@ -0,0 +1,211 @@
+#[cfg(feature = "rpk")]
+use crate::cvt_p;
+use crate::error::ErrorStack;
+use crate::ex_data::Index;
+use crate::pkey::{PKeyRef, Private};
+use crate::ssl::callbacks;
+use crate::ssl::PrivateKeyMethod;
+use crate::{cvt_0i, cvt_n};
+use crate::{ffi, free_data_box};
+use foreign_types::{ForeignType, ForeignTypeRef};
+use openssl_macros::corresponds;
+use std::any::TypeId;
+use std::collections::HashMap;
+use std::ffi::{c_int, c_void};
+use std::mem;
+use std::ptr;
+use std::sync::{LazyLock, Mutex};
+
+static SSL_CREDENTIAL_INDEXES: LazyLock<Mutex<HashMap<TypeId, c_int>>> =
+    LazyLock::new(|| Mutex::new(HashMap::new()));
+
+foreign_type_and_impl_send_sync! {
+    type CType = ffi::SSL_CREDENTIAL;
+    fn drop = ffi::SSL_CREDENTIAL_free;
+
+    /// A credential.
+    pub struct SslCredential;
+}
+
+impl SslCredential {
+    /// Create a credential suitable for a handshake using a raw public key.
+    #[corresponds(SSL_CREDENTIAL_new_raw_public_key)]
+    #[cfg(feature = "rpk")]
+    pub fn new_raw_public_key() -> Result<SslCredentialBuilder, ErrorStack> {
+        unsafe {
+            Ok(SslCredentialBuilder(Self::from_ptr(cvt_p(
+                ffi::SSL_CREDENTIAL_new_raw_public_key(),
+            )?)))
+        }
+    }
+
+    /// Returns a new extra data index.
+    ///
+    /// Each invocation of this function is guaranteed to return a distinct index. These can be used
+    /// to store data in the context that can be retrieved later by callbacks, for example.
+    #[corresponds(SSL_C_get_ex_new_index)]
+    pub fn new_ex_index<T>() -> Result<Index<Self, T>, ErrorStack>
+    where
+        T: 'static + Sync + Send,
+    {
+        unsafe {
+            ffi::init();
+            let idx = cvt_n(get_new_ssl_credential_idx(Some(free_data_box::<T>)))?;
+            Ok(Index::from_raw(idx))
+        }
+    }
+
+    // FIXME should return a result?
+    pub(crate) fn cached_ex_index<T>() -> Index<Self, T>
+    where
+        T: 'static + Sync + Send,
+    {
+        unsafe {
+            let idx = *SSL_CREDENTIAL_INDEXES
+                .lock()
+                .unwrap_or_else(|e| e.into_inner())
+                .entry(TypeId::of::<T>())
+                .or_insert_with(|| Self::new_ex_index::<T>().unwrap().as_raw());
+            Index::from_raw(idx)
+        }
+    }
+}
+
+impl SslCredentialRef {
+    /// Returns a reference to the extra data at the specified index.
+    #[corresponds(SSL_CREDENTIAL_get_ex_data)]
+    #[must_use]
+    pub fn ex_data<T>(&self, index: Index<SslCredential, T>) -> Option<&T> {
+        unsafe {
+            let data = ffi::SSL_CREDENTIAL_get_ex_data(self.as_ptr(), index.as_raw());
+            if data.is_null() {
+                None
+            } else {
+                Some(&*(data as *const T))
+            }
+        }
+    }
+
+    // Unsafe because SSL contexts are not guaranteed to be unique, we call
+    // this only from SslCredentialBuilder.
+    #[corresponds(SSL_CREDENTIAL_get_ex_data)]
+    pub(crate) unsafe fn ex_data_mut<T>(
+        &mut self,
+        index: Index<SslCredential, T>,
+    ) -> Option<&mut T> {
+        let data = ffi::SSL_CREDENTIAL_get_ex_data(self.as_ptr(), index.as_raw());
+        if data.is_null() {
+            None
+        } else {
+            Some(&mut *(data as *mut T))
+        }
+    }
+
+    // Unsafe because SSL contexts are not guaranteed to be unique, we call
+    // this only from SslCredentialBuilder.
+    #[corresponds(SSL_CREDENTIAL_set_ex_data)]
+    pub(crate) unsafe fn replace_ex_data<T>(
+        &mut self,
+        index: Index<SslCredential, T>,
+        data: T,
+    ) -> Option<T> {
+        if let Some(old) = self.ex_data_mut(index) {
+            return Some(mem::replace(old, data));
+        }
+
+        unsafe {
+            let data = Box::into_raw(Box::new(data)) as *mut c_void;
+            ffi::SSL_CREDENTIAL_set_ex_data(self.as_ptr(), index.as_raw(), data);
+        }
+
+        None
+    }
+}
+
+/// A builder for [`SslCredential`]
+pub struct SslCredentialBuilder(SslCredential);
+
+impl SslCredentialBuilder {
+    /// Sets or overwrites the extra data at the specified index.
+    ///
+    /// This can be used to provide data to callbacks registered with the context. Use the
+    /// `SslCredential::new_ex_index` method to create an `Index`.
+    ///
+    /// Any previous value will be returned and replaced by the new one.
+    #[corresponds(SSL_CREDENTIAL_set_ex_data)]
+    pub fn replace_ex_data<T>(&mut self, index: Index<SslCredential, T>, data: T) -> Option<T> {
+        unsafe { self.0.replace_ex_data(index, data) }
+    }
+
+    // Sets the private key of the credential.
+    #[corresponds(SSL_CREDENTIAL_set1_private_key)]
+    pub fn set_private_key(&mut self, private_key: &PKeyRef<Private>) -> Result<(), ErrorStack> {
+        unsafe {
+            cvt_0i(ffi::SSL_CREDENTIAL_set1_private_key(
+                self.0.as_ptr(),
+                private_key.as_ptr(),
+            ))
+            .map(|_| ())
+        }
+    }
+
+    /// Configures a custom private key method on the credential.
+    ///
+    /// See [`PrivateKeyMethod`] for more details.
+    #[corresponds(SSL_CREDENTIAL_set_private_key_method)]
+    pub fn set_private_key_method<M>(&mut self, method: M) -> Result<(), ErrorStack>
+    where
+        M: PrivateKeyMethod,
+    {
+        unsafe {
+            self.replace_ex_data(SslCredential::cached_ex_index::<M>(), method);
+
+            cvt_0i(ffi::SSL_CREDENTIAL_set_private_key_method(
+                self.0.as_ptr(),
+                &ffi::SSL_PRIVATE_KEY_METHOD {
+                    sign: Some(callbacks::raw_sign::<M>),
+                    decrypt: Some(callbacks::raw_decrypt::<M>),
+                    complete: Some(callbacks::raw_complete::<M>),
+                },
+            ))
+            .map(|_| ())
+        }
+    }
+
+    // Sets the SPKI of the raw public key credential.
+    //
+    // If `spki` is `None`, the SPKI is extracted from the credential's private key.
+    #[corresponds(SSL_CREDENTIAL_set1_spki)]
+    #[cfg(feature = "rpk")]
+    pub fn set_spki_bytes(&mut self, spki: Option<&[u8]>) -> Result<(), ErrorStack> {
+        unsafe {
+            let spki = spki
+                .map(|spki| {
+                    cvt_p(ffi::CRYPTO_BUFFER_new(
+                        spki.as_ptr(),
+                        spki.len(),
+                        ptr::null_mut(),
+                    ))
+                })
+                .transpose()?
+                .unwrap_or(ptr::null_mut());
+
+            let ret = cvt_0i(ffi::SSL_CREDENTIAL_set1_spki(self.0.as_ptr(), spki)).map(|_| ());
+
+            if !spki.is_null() {
+                ffi::CRYPTO_BUFFER_free(spki);
+            }
+
+            ret
+        }
+    }
+
+    #[must_use]
+    pub fn build(self) -> SslCredential {
+        self.0
+    }
+}
+
+unsafe fn get_new_ssl_credential_idx(f: ffi::CRYPTO_EX_free) -> c_int {
+    ffi::SSL_CREDENTIAL_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, f)
+}
diff --git a/boring/src/ssl/error.rs b/boring/src/ssl/error.rs
index 5acad820..1766724c 100644
--- a/boring/src/ssl/error.rs
+++ b/boring/src/ssl/error.rs
@@ -79,6 +79,7 @@ impl ErrorCode {
     }
 
     #[corresponds(SSL_error_description)]
+    #[must_use]
     pub fn description(self) -> Option<&'static str> {
         unsafe {
             let msg = ffi::SSL_error_description(self.0);
@@ -249,8 +250,7 @@ fn fmt_mid_handshake_error(
     f: &mut fmt::Formatter,
     prefix: &str,
 ) -> fmt::Result {
-    #[cfg(feature = "rpk")]
-    if s.ssl().ssl_context().is_rpk() {
+    if !s.ssl().ssl_context().has_x509_support() {
         write!(f, "{}", prefix)?;
         return write!(f, " {}", s.error());
     }
diff --git a/boring/src/ssl/mod.rs b/boring/src/ssl/mod.rs
index 5c6adee9..103bd623 100644
--- a/boring/src/ssl/mod.rs
+++ b/boring/src/ssl/mod.rs
@@ -58,18 +58,18 @@
 //! }
 //! ```
 use foreign_types::{ForeignType, ForeignTypeRef, Opaque};
-use libc::{c_char, c_int, c_uchar, c_uint, c_void};
 use openssl_macros::corresponds;
 use std::any::TypeId;
 use std::collections::HashMap;
 use std::convert::TryInto;
+use std::ffi::{c_char, c_int, c_uchar, c_uint};
 use std::ffi::{CStr, CString};
 use std::fmt;
 use std::io;
 use std::io::prelude::*;
 use std::marker::PhantomData;
 use std::mem::{self, ManuallyDrop, MaybeUninit};
-use std::ops::{Deref, DerefMut};
+use std::ops::Deref;
 use std::panic::resume_unwind;
 use std::path::Path;
 use std::ptr::{self, NonNull};
@@ -83,6 +83,8 @@ use crate::error::ErrorStack;
 use crate::ex_data::Index;
 use crate::hmac::HmacCtxRef;
 use crate::nid::Nid;
+#[cfg(feature = "rpk")]
+use crate::pkey::Public;
 use crate::pkey::{HasPrivate, PKeyRef, Params, Private};
 use crate::srtp::{SrtpProtectionProfile, SrtpProtectionProfileRef};
 use crate::ssl::bio::BioMethod;
@@ -90,6 +92,7 @@ use crate::ssl::callbacks::*;
 use crate::ssl::error::InnerError;
 use crate::stack::{Stack, StackRef, Stackable};
 use crate::symm::CipherCtxRef;
+use crate::try_int;
 use crate::x509::store::{X509Store, X509StoreBuilder, X509StoreBuilderRef, X509StoreRef};
 use crate::x509::verify::X509VerifyParamRef;
 use crate::x509::{
@@ -106,6 +109,7 @@ pub use self::async_callbacks::{
 pub use self::connector::{
     ConnectConfiguration, SslAcceptor, SslAcceptorBuilder, SslConnector, SslConnectorBuilder,
 };
+pub use self::credential::{SslCredential, SslCredentialBuilder, SslCredentialRef};
 pub use self::ech::{SslEchKeys, SslEchKeysRef};
 pub use self::error::{Error, ErrorCode, HandshakeError};
 
@@ -113,6 +117,7 @@ mod async_callbacks;
 mod bio;
 mod callbacks;
 mod connector;
+mod credential;
 mod ech;
 mod error;
 mod mut_only;
@@ -246,59 +251,87 @@ bitflags! {
 
 /// A type specifying the kind of protocol an `SslContext` will speak.
 #[derive(Copy, Clone)]
-pub struct SslMethod(*const ffi::SSL_METHOD);
+pub struct SslMethod {
+    ptr: *const ffi::SSL_METHOD,
+    is_x509_method: bool,
+}
 
 impl SslMethod {
     /// Support all versions of the TLS protocol.
     #[corresponds(TLS_method)]
     #[must_use]
-    pub fn tls() -> SslMethod {
-        unsafe { SslMethod(TLS_method()) }
+    pub fn tls() -> Self {
+        unsafe {
+            Self {
+                ptr: ffi::TLS_method(),
+                is_x509_method: true,
+            }
+        }
     }
 
-    /// Same as `tls`, but doesn't create X509 for certificates.
-    #[cfg(feature = "rpk")]
-    pub fn tls_with_buffer() -> SslMethod {
-        unsafe { SslMethod(ffi::TLS_with_buffers_method()) }
+    /// Same as `tls`, but doesn't create X.509 for certificates.
+    ///
+    /// # Safety
+    ///
+    /// BoringSSL will crash if the user calls a function that involves
+    /// X.509 certificates with an object configured with this method.
+    /// You most probably don't need it.
+    #[must_use]
+    pub unsafe fn tls_with_buffer() -> Self {
+        unsafe {
+            Self {
+                ptr: ffi::TLS_with_buffers_method(),
+                is_x509_method: false,
+            }
+        }
     }
 
     /// Support all versions of the DTLS protocol.
     #[corresponds(DTLS_method)]
     #[must_use]
-    pub fn dtls() -> SslMethod {
-        unsafe { SslMethod(DTLS_method()) }
-    }
-
-    /// Support all versions of the TLS protocol, explicitly as a client.
-    #[corresponds(TLS_client_method)]
-    #[must_use]
-    pub fn tls_client() -> SslMethod {
-        unsafe { SslMethod(TLS_client_method()) }
-    }
-
-    /// Support all versions of the TLS protocol, explicitly as a server.
-    #[corresponds(TLS_server_method)]
-    #[must_use]
-    pub fn tls_server() -> SslMethod {
-        unsafe { SslMethod(TLS_server_method()) }
+    pub fn dtls() -> Self {
+        unsafe {
+            Self {
+                ptr: ffi::DTLS_method(),
+                is_x509_method: true,
+            }
+        }
     }
 
     /// Constructs an `SslMethod` from a pointer to the underlying OpenSSL value.
     ///
+    /// This method assumes that the `SslMethod` is not configured for X.509
+    /// certificates. The user can call `SslMethod::assume_x509_method`
+    /// to change that.
+    ///
     /// # Safety
     ///
     /// The caller must ensure the pointer is valid.
     #[corresponds(TLS_server_method)]
     #[must_use]
     pub unsafe fn from_ptr(ptr: *const ffi::SSL_METHOD) -> SslMethod {
-        SslMethod(ptr)
+        SslMethod {
+            ptr,
+            is_x509_method: false,
+        }
+    }
+
+    /// Assumes that this `SslMethod` is configured for X.509 certificates.
+    ///
+    /// # Safety
+    ///
+    /// BoringSSL will crash if the user calls a function that involves
+    /// X.509 certificates with an object configured with this method.
+    /// You most probably don't need it.
+    pub unsafe fn assume_x509(&mut self) {
+        self.is_x509_method = true;
     }
 
     /// Returns a pointer to the underlying OpenSSL value.
     #[allow(clippy::trivially_copy_pass_by_ref)]
     #[must_use]
     pub fn as_ptr(&self) -> *const ffi::SSL_METHOD {
-        self.0
+        self.ptr
     }
 }
 
@@ -450,8 +483,7 @@ static SSL_INDEXES: LazyLock<Mutex<HashMap<TypeId, c_int>>> =
     LazyLock::new(|| Mutex::new(HashMap::new()));
 static SESSION_CTX_INDEX: LazyLock<Index<Ssl, SslContext>> =
     LazyLock::new(|| Ssl::new_ex_index().unwrap());
-#[cfg(feature = "rpk")]
-static RPK_FLAG_INDEX: LazyLock<Index<SslContext, bool>> =
+static X509_FLAG_INDEX: LazyLock<Index<SslContext, bool>> =
     LazyLock::new(|| SslContext::new_ex_index().unwrap());
 
 /// An error returned from the SNI callback.
@@ -571,7 +603,6 @@ impl ExtensionType {
     pub const RENEGOTIATE: Self = Self(ffi::TLSEXT_TYPE_renegotiate as u16);
     pub const DELEGATED_CREDENTIAL: Self = Self(ffi::TLSEXT_TYPE_delegated_credential as u16);
     pub const APPLICATION_SETTINGS: Self = Self(ffi::TLSEXT_TYPE_application_settings as u16);
-    pub const APPLICATION_SETTINGS_NEW: Self = Self(ffi::TLSEXT_TYPE_application_settings as u16);
     pub const ENCRYPTED_CLIENT_HELLO: Self = Self(ffi::TLSEXT_TYPE_encrypted_client_hello as u16);
     pub const CERTIFICATE_TIMESTAMP: Self = Self(ffi::TLSEXT_TYPE_certificate_timestamp as u16);
     pub const NEXT_PROTO_NEG: Self = Self(ffi::TLSEXT_TYPE_next_proto_neg as u16);
@@ -759,13 +790,13 @@ pub fn select_next_proto<'a>(server: &'a [u8], client: &'a [u8]) -> Option<&'a [
             &mut out,
             &mut outlen,
             server.as_ptr(),
-            server.len() as c_uint,
+            try_int(server.len()).ok()?,
             client.as_ptr(),
-            client.len() as c_uint,
+            try_int(client.len()).ok()?,
         );
 
         if r == ffi::OPENSSL_NPN_NEGOTIATED {
-            Some(slice::from_raw_parts(out as *const u8, outlen as usize))
+            Some(slice::from_raw_parts(out.cast_const(), outlen as usize))
         } else {
             None
         }
@@ -887,67 +918,11 @@ impl Ssl3AlertLevel {
     pub const FATAL: Ssl3AlertLevel = Self(ffi::SSL3_AL_FATAL);
 }
 
-#[cfg(feature = "rpk")]
-extern "C" fn rpk_verify_failure_callback(
-    _ssl: *mut ffi::SSL,
-    _out_alert: *mut u8,
-) -> ffi::ssl_verify_result_t {
-    // Always verify the peer.
-    ffi::ssl_verify_result_t::ssl_verify_invalid
-}
-
 /// A builder for `SslContext`s.
 pub struct SslContextBuilder {
     ctx: SslContext,
     /// If it's not shared, it can be exposed as mutable
     has_shared_cert_store: bool,
-    #[cfg(feature = "rpk")]
-    is_rpk: bool,
-}
-
-#[cfg(feature = "rpk")]
-impl SslContextBuilder {
-    /// Creates a new `SslContextBuilder` to be used with Raw Public Key.
-    #[corresponds(SSL_CTX_new)]
-    pub fn new_rpk() -> Result<SslContextBuilder, ErrorStack> {
-        unsafe {
-            init();
-            let ctx = cvt_p(ffi::SSL_CTX_new(SslMethod::tls_with_buffer().as_ptr()))?;
-
-            let mut builder = SslContextBuilder::from_ptr(ctx);
-            builder.is_rpk = true;
-            builder.set_ex_data(*RPK_FLAG_INDEX, true);
-
-            Ok(builder)
-        }
-    }
-
-    /// Sets raw public key certificate in DER format.
-    pub fn set_rpk_certificate(&mut self, cert: &[u8]) -> Result<(), ErrorStack> {
-        unsafe {
-            cvt(ffi::SSL_CTX_set_server_raw_public_key_certificate(
-                self.as_ptr(),
-                cert.as_ptr(),
-                cert.len() as u32,
-            ))
-            .map(|_| ())
-        }
-    }
-
-    /// Sets RPK null chain private key.
-    pub fn set_null_chain_private_key<T>(&mut self, key: &PKeyRef<T>) -> Result<(), ErrorStack>
-    where
-        T: HasPrivate,
-    {
-        unsafe {
-            cvt(ffi::SSL_CTX_set_nullchain_and_key(
-                self.as_ptr(),
-                key.as_ptr(),
-                ptr::null_mut(),
-            ))
-            .map(|_| ())
-        }
-    }
 }
 
 impl SslContextBuilder {
@@ -957,31 +932,45 @@ impl SslContextBuilder {
         unsafe {
             init();
             let ctx = cvt_p(ffi::SSL_CTX_new(method.as_ptr()))?;
-            Ok(SslContextBuilder::from_ptr(ctx))
+            let mut builder = SslContextBuilder::from_ptr(ctx);
+
+            if method.is_x509_method {
+                builder.ctx.assume_x509();
+            }
+
+            Ok(builder)
         }
     }
 
     /// Creates an `SslContextBuilder` from a pointer to a raw OpenSSL value.
     ///
-    #[cfg_attr(
-        feature = "rpk",
-        doc = "Keeps previous RPK state. Use `new_rpk()` to enable RPK."
-    )]
+    /// This method can find out whether `ctx` is configured for X.509 certificates
+    /// if `ctx` was itself a context created by this crate. If it was created by
+    /// other means and it supports X.509 certificates, the use can call
+    /// `SslContextBuilder::assume_x509`.
     ///
     /// # Safety
     ///
     /// The caller must ensure that the pointer is valid and uniquely owned by the builder.
     /// The context must own its cert store exclusively.
-    pub unsafe fn from_ptr(ctx: *mut ffi::SSL_CTX) -> SslContextBuilder {
-        let ctx = SslContext::from_ptr(ctx);
-        SslContextBuilder {
-            #[cfg(feature = "rpk")]
-            is_rpk: ctx.is_rpk(),
+    pub unsafe fn from_ptr(ctx: *mut ffi::SSL_CTX) -> Self {
+        Self {
+            ctx: SslContext::from_ptr(ctx),
             has_shared_cert_store: false,
-            ctx,
         }
     }
 
+    /// Assumes that this `SslContextBuilder` is configured for X.509 certificates.
+    ///
+    /// # Safety
+    ///
+    /// BoringSSL will crash if the user calls a function that involves
+    /// X.509 certificates with an object configured with this method.
+    /// You most probably don't need it.
+    pub unsafe fn assume_x509(&mut self) {
+        self.ctx.assume_x509();
+    }
+
     /// Returns a pointer to the raw OpenSSL value.
     #[must_use]
     pub fn as_ptr(&self) -> *mut ffi::SSL_CTX {
@@ -998,11 +987,11 @@ impl SslContextBuilder {
     /// whether the chain is accepted or not.
     ///
     /// *Warning*: Providing a complete verification procedure is a complex task. See
-    /// https://docs.openssl.org/master/man3/SSL_CTX_set_cert_verify_callback/#notes for more
-    /// information.
+    /// [`SSL_CTX_set_cert_verify_callback`](https://docs.openssl.org/master/man3/SSL_CTX_set_cert_verify_callback/#notes)
+    /// for more information.
     ///
-    /// TODO: Add the ability to unset the callback by either adding a new function or wrapping the
-    /// callback in an `Option`.
+    // TODO: Add the ability to unset the callback by either adding a new function or wrapping the
+    // callback in an `Option`.
     ///
     /// # Panics
     ///
@@ -1012,8 +1001,7 @@ impl SslContextBuilder {
     where
         F: Fn(&mut X509StoreContextRef) -> bool + 'static + Sync + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         // NOTE(jlarisch): Q: Why don't we wrap the callback in an Arc, since
         // `set_verify_callback` does?
@@ -1034,11 +1022,10 @@ impl SslContextBuilder {
     /// Configures the certificate verification method for new connections.
     #[corresponds(SSL_CTX_set_verify)]
     pub fn set_verify(&mut self, mode: SslVerifyMode) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
-            ffi::SSL_CTX_set_verify(self.as_ptr(), mode.bits() as c_int, None);
+            ffi::SSL_CTX_set_verify(self.as_ptr(), c_int::from(mode.bits()), None);
         }
     }
 
@@ -1063,12 +1050,15 @@ impl SslContextBuilder {
     where
         F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
             self.replace_ex_data(SslContext::cached_ex_index::<F>(), callback);
-            ffi::SSL_CTX_set_verify(self.as_ptr(), mode.bits() as c_int, Some(raw_verify::<F>));
+            ffi::SSL_CTX_set_verify(
+                self.as_ptr(),
+                c_int::from(mode.bits()),
+                Some(raw_verify::<F>),
+            );
         }
     }
 
@@ -1091,14 +1081,11 @@ impl SslContextBuilder {
     where
         F: Fn(&mut SslRef) -> Result<(), SslVerifyError> + 'static + Sync + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
-
         unsafe {
             self.replace_ex_data(SslContext::cached_ex_index::<F>(), callback);
             ffi::SSL_CTX_set_custom_verify(
                 self.as_ptr(),
-                mode.bits() as c_int,
+                c_int::from(mode.bits()),
                 Some(raw_custom_verify::<F>),
             );
         }
@@ -1128,9 +1115,9 @@ impl SslContextBuilder {
             let callback_index = SslContext::cached_ex_index::<F>();
 
             self.ctx.replace_ex_data(callback_index, callback);
+            let callback = self.ctx.ex_data(callback_index).unwrap();
 
-            let arg = self.ctx.ex_data(callback_index).unwrap() as *const F as *mut c_void;
-
+            let arg = std::ptr::from_ref(callback).cast_mut().cast();
             ffi::SSL_CTX_set_tlsext_servername_arg(self.as_ptr(), arg);
             ffi::SSL_CTX_set_tlsext_servername_callback(self.as_ptr(), Some(raw_sni::<F>));
         }
@@ -1173,8 +1160,7 @@ impl SslContextBuilder {
             + Sync
             + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
             self.replace_ex_data(SslContext::cached_ex_index::<F>(), callback);
@@ -1187,8 +1173,7 @@ impl SslContextBuilder {
     /// If the peer's certificate chain is longer than this value, verification will fail.
     #[corresponds(SSL_CTX_set_verify_depth)]
     pub fn set_verify_depth(&mut self, depth: u32) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
             ffi::SSL_CTX_set_verify_depth(self.as_ptr(), depth as c_int);
@@ -1198,28 +1183,27 @@ impl SslContextBuilder {
     /// Sets a custom certificate store for verifying peer certificates.
     #[corresponds(SSL_CTX_set0_verify_cert_store)]
     pub fn set_verify_cert_store(&mut self, cert_store: X509Store) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
-            cvt(
-                ffi::SSL_CTX_set0_verify_cert_store(self.as_ptr(), cert_store.into_ptr()) as c_int,
-            )?;
-
-            Ok(())
+            cvt(ffi::SSL_CTX_set0_verify_cert_store(
+                self.as_ptr(),
+                cert_store.into_ptr(),
+            ))
         }
     }
 
-    /// Use [`set_cert_store_builder`] or [`set_cert_store_ref`] instead.
+    /// Replaces the context's certificate store, and keeps it immutable.
     ///
-    /// Replaces the context's certificate store.
+    /// This method allows sharing the `X509Store`, but calls to `cert_store_mut` will panic.
+    ///
+    /// Use [`set_cert_store_builder`] to set a mutable cert store
+    /// (there's no way to have both sharing and mutability).
     #[corresponds(SSL_CTX_set_cert_store)]
-    #[deprecated(note = "Use set_cert_store_builder or set_cert_store_ref instead")]
     pub fn set_cert_store(&mut self, cert_store: X509Store) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
-        self.has_shared_cert_store = false;
+        self.has_shared_cert_store = true;
         unsafe {
             ffi::SSL_CTX_set_cert_store(self.as_ptr(), cert_store.into_ptr());
         }
@@ -1228,8 +1212,7 @@ impl SslContextBuilder {
     /// Replaces the context's certificate store, and allows mutating the store afterwards.
     #[corresponds(SSL_CTX_set_cert_store)]
     pub fn set_cert_store_builder(&mut self, cert_store: X509StoreBuilder) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         self.has_shared_cert_store = false;
         unsafe {
@@ -1242,14 +1225,7 @@ impl SslContextBuilder {
     /// This method allows sharing the `X509Store`, but calls to `cert_store_mut` will panic.
     #[corresponds(SSL_CTX_set_cert_store)]
     pub fn set_cert_store_ref(&mut self, cert_store: &X509Store) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
-
-        self.has_shared_cert_store = true;
-        unsafe {
-            ffi::X509_STORE_up_ref(cert_store.as_ptr());
-            ffi::SSL_CTX_set_cert_store(self.as_ptr(), cert_store.as_ptr());
-        }
+        self.set_cert_store(cert_store.to_owned());
     }
 
     /// Controls read ahead behavior.
@@ -1275,13 +1251,13 @@ impl SslContextBuilder {
     /// Sets the parameters to be used during ephemeral Diffie-Hellman key exchange.
     #[corresponds(SSL_CTX_set_tmp_dh)]
     pub fn set_tmp_dh(&mut self, dh: &DhRef<Params>) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_set_tmp_dh(self.as_ptr(), dh.as_ptr()) as c_int).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_set_tmp_dh(self.as_ptr(), dh.as_ptr())) }
     }
 
     /// Sets the parameters to be used during ephemeral elliptic curve Diffie-Hellman key exchange.
     #[corresponds(SSL_CTX_set_tmp_ecdh)]
     pub fn set_tmp_ecdh(&mut self, key: &EcKeyRef<Params>) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_set_tmp_ecdh(self.as_ptr(), key.as_ptr()) as c_int).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_set_tmp_ecdh(self.as_ptr(), key.as_ptr())) }
     }
 
     /// Use the default locations of trusted certificates for verification.
@@ -1290,10 +1266,9 @@ impl SslContextBuilder {
     /// if present, or defaults specified at OpenSSL build time otherwise.
     #[corresponds(SSL_CTX_set_default_verify_paths)]
     pub fn set_default_verify_paths(&mut self) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
-        unsafe { cvt(ffi::SSL_CTX_set_default_verify_paths(self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_set_default_verify_paths(self.as_ptr())) }
     }
 
     /// Loads trusted root certificates from a file.
@@ -1301,18 +1276,16 @@ impl SslContextBuilder {
     /// The file should contain a sequence of PEM-formatted CA certificates.
     #[corresponds(SSL_CTX_load_verify_locations)]
     pub fn set_ca_file<P: AsRef<Path>>(&mut self, file: P) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         let file = CString::new(file.as_ref().as_os_str().as_encoded_bytes())
             .map_err(ErrorStack::internal_error)?;
         unsafe {
             cvt(ffi::SSL_CTX_load_verify_locations(
                 self.as_ptr(),
-                file.as_ptr() as *const _,
+                file.as_ptr(),
                 ptr::null(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1322,8 +1295,7 @@ impl SslContextBuilder {
     /// as trusted by this method.
     #[corresponds(SSL_CTX_set_client_CA_list)]
     pub fn set_client_ca_list(&mut self, list: Stack<X509Name>) {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
             ffi::SSL_CTX_set_client_CA_list(self.as_ptr(), list.as_ptr());
@@ -1335,10 +1307,9 @@ impl SslContextBuilder {
     /// requesting client-side TLS authentication.
     #[corresponds(SSL_CTX_add_client_CA)]
     pub fn add_client_ca(&mut self, cacert: &X509Ref) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
-        unsafe { cvt(ffi::SSL_CTX_add_client_CA(self.as_ptr(), cacert.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_add_client_CA(self.as_ptr(), cacert.as_ptr())) }
     }
 
     /// Set the context identifier for sessions.
@@ -1358,7 +1329,6 @@ impl SslContextBuilder {
                 sid_ctx.as_ptr(),
                 sid_ctx.len(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1373,18 +1343,16 @@ impl SslContextBuilder {
         file: P,
         file_type: SslFiletype,
     ) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         let file = CString::new(file.as_ref().as_os_str().as_encoded_bytes())
             .map_err(ErrorStack::internal_error)?;
         unsafe {
             cvt(ffi::SSL_CTX_use_certificate_file(
                 self.as_ptr(),
-                file.as_ptr() as *const _,
+                file.as_ptr(),
                 file_type.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1403,9 +1371,8 @@ impl SslContextBuilder {
         unsafe {
             cvt(ffi::SSL_CTX_use_certificate_chain_file(
                 self.as_ptr(),
-                file.as_ptr() as *const _,
+                file.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1414,7 +1381,7 @@ impl SslContextBuilder {
     /// Use `add_extra_chain_cert` to add the remainder of the certificate chain.
     #[corresponds(SSL_CTX_use_certificate)]
     pub fn set_certificate(&mut self, cert: &X509Ref) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_use_certificate(self.as_ptr(), cert.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_use_certificate(self.as_ptr(), cert.as_ptr())) }
     }
 
     /// Appends a certificate to the certificate chain.
@@ -1423,12 +1390,13 @@ impl SslContextBuilder {
     /// `set_certificate` to a trusted root.
     #[corresponds(SSL_CTX_add_extra_chain_cert)]
     pub fn add_extra_chain_cert(&mut self, cert: X509) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe {
-            cvt(ffi::SSL_CTX_add_extra_chain_cert(self.as_ptr(), cert.into_ptr()) as c_int)?;
-            Ok(())
+            cvt(ffi::SSL_CTX_add_extra_chain_cert(
+                self.as_ptr(),
+                cert.into_ptr(),
+            ))
         }
     }
 
@@ -1444,10 +1412,9 @@ impl SslContextBuilder {
         unsafe {
             cvt(ffi::SSL_CTX_use_PrivateKey_file(
                 self.as_ptr(),
-                file.as_ptr() as *const _,
+                file.as_ptr(),
                 file_type.as_raw(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1457,27 +1424,49 @@ impl SslContextBuilder {
     where
         T: HasPrivate,
     {
-        unsafe { cvt(ffi::SSL_CTX_use_PrivateKey(self.as_ptr(), key.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_use_PrivateKey(self.as_ptr(), key.as_ptr())) }
     }
 
-    /// Sets the list of supported ciphers for protocols before TLSv1.3.
+    /// Sets the list of supported ciphers for protocols before TLSv1.3, ignoring meaningless entries.
+    ///
+    /// See [`SslContextBuilder::set_strict_cipher_list()`].
     ///
     /// The `set_ciphersuites` method controls the cipher suites for TLSv1.3 in OpenSSL.
     /// BoringSSL doesn't implement `set_ciphersuites`.
-    /// See https://github.com/google/boringssl/blob/master/include/openssl/ssl.h#L1542-L1544
+    /// See [ssl.h](https://github.com/google/boringssl/blob/master/include/openssl/ssl.h#L1542-L1544).
     ///
     /// See [`ciphers`] for details on the format.
     ///
     /// [`ciphers`]: https://www.openssl.org/docs/manmaster/apps/ciphers.html
     #[corresponds(SSL_CTX_set_cipher_list)]
     pub fn set_cipher_list(&mut self, cipher_list: &str) -> Result<(), ErrorStack> {
-        let cipher_list = CString::new(cipher_list).unwrap();
+        let cipher_list = CString::new(cipher_list).map_err(ErrorStack::internal_error)?;
         unsafe {
             cvt(ffi::SSL_CTX_set_cipher_list(
                 self.as_ptr(),
-                cipher_list.as_ptr() as *const _,
+                cipher_list.as_ptr(),
+            ))
+        }
+    }
+
+    /// Sets the list of supported ciphers for protocols before TLSv1.3 but do not
+    /// tolerate anything meaningless in the cipher list.
+    ///
+    /// The `set_ciphersuites` method controls the cipher suites for TLSv1.3 in OpenSSL.
+    /// BoringSSL doesn't implement `set_ciphersuites`.
+    /// See <https://github.com/google/boringssl/blob/main/include/openssl/ssl.h#L1685>
+    ///
+    /// See [`ciphers`] for details on the format.
+    ///
+    /// [`ciphers`]: <https://docs.openssl.org/master/man1/openssl-ciphers/>.
+    #[corresponds(SSL_CTX_set_strict_cipher_list)]
+    pub fn set_strict_cipher_list(&mut self, cipher_list: &str) -> Result<(), ErrorStack> {
+        let cipher_list = CString::new(cipher_list).map_err(ErrorStack::internal_error)?;
+        unsafe {
+            cvt(ffi::SSL_CTX_set_strict_cipher_list(
+                self.as_ptr(),
+                cipher_list.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1530,7 +1519,6 @@ impl SslContextBuilder {
                 self.as_ptr(),
                 version.map_or(0, |v| v.0 as _),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1544,7 +1532,6 @@ impl SslContextBuilder {
                 self.as_ptr(),
                 version.map_or(0, |v| v.0 as _),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1583,17 +1570,10 @@ impl SslContextBuilder {
     #[corresponds(SSL_CTX_set_alpn_protos)]
     pub fn set_alpn_protos(&mut self, protocols: &[u8]) -> Result<(), ErrorStack> {
         unsafe {
-            #[cfg_attr(
-                not(feature = "legacy-compat-deprecated"),
-                allow(clippy::unnecessary_cast)
-            )]
-            {
-                assert!(protocols.len() <= ProtosLen::MAX as usize);
-            }
             let r = ffi::SSL_CTX_set_alpn_protos(
                 self.as_ptr(),
                 protocols.as_ptr(),
-                protocols.len() as ProtosLen,
+                try_int(protocols.len())?,
             );
             // fun fact, SSL_CTX_set_alpn_protos has a reversed return code D:
             if r == 0 {
@@ -1674,7 +1654,7 @@ impl SslContextBuilder {
         C: CertificateCompressor,
     {
         const {
-            assert!(C::CAN_COMPRESS || C::CAN_DECOMPRESS, "Either compression or decompression must be supported for algorithm to be registered")
+            assert!(C::CAN_COMPRESS || C::CAN_DECOMPRESS, "Either compression or decompression must be supported for algorithm to be registered");
         };
         let success = unsafe {
             ffi::SSL_CTX_add_cert_compression_alg(
@@ -1721,22 +1701,21 @@ impl SslContextBuilder {
                     decrypt: Some(callbacks::raw_decrypt::<M>),
                     complete: Some(callbacks::raw_complete::<M>),
                 },
-            )
+            );
         }
     }
 
     /// Checks for consistency between the private key and certificate.
     #[corresponds(SSL_CTX_check_private_key)]
     pub fn check_private_key(&self) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_check_private_key(self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_check_private_key(self.as_ptr())) }
     }
 
     /// Returns a shared reference to the context's certificate store.
     #[corresponds(SSL_CTX_get_cert_store)]
     #[must_use]
     pub fn cert_store(&self) -> &X509StoreBuilderRef {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         unsafe { X509StoreBuilderRef::from_ptr(ffi::SSL_CTX_get_cert_store(self.as_ptr())) }
     }
@@ -1752,12 +1731,12 @@ impl SslContextBuilder {
     ///
     #[corresponds(SSL_CTX_get_cert_store)]
     pub fn cert_store_mut(&mut self) -> &mut X509StoreBuilderRef {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk, "This API is not supported for RPK");
+        self.ctx.check_x509();
 
         assert!(
             !self.has_shared_cert_store,
-            "Shared X509Store can't be mutated. Make a new store"
+            "Shared X509Store can't be mutated. Use set_cert_store_builder() instead of set_cert_store()
+                or completely finish building the cert store setting it."
         );
         // OTOH, it's not safe to return a shared &X509Store when the builder owns it exclusively
 
@@ -1783,11 +1762,10 @@ impl SslContextBuilder {
     {
         unsafe {
             self.replace_ex_data(SslContext::cached_ex_index::<F>(), callback);
-            cvt(
-                ffi::SSL_CTX_set_tlsext_status_cb(self.as_ptr(), Some(raw_tlsext_status::<F>))
-                    as c_int,
-            )
-            .map(|_| ())
+            cvt(ffi::SSL_CTX_set_tlsext_status_cb(
+                self.as_ptr(),
+                Some(raw_tlsext_status::<F>),
+            ))
         }
     }
 
@@ -1934,20 +1912,17 @@ impl SslContextBuilder {
     ///
     /// This can be used to provide data to callbacks registered with the context. Use the
     /// `SslContext::new_ex_index` method to create an `Index`.
-    ///
-    /// Note that if this method is called multiple times with the same index, any previous
-    /// value stored in the `SslContextBuilder` will be leaked.
     #[corresponds(SSL_CTX_set_ex_data)]
     pub fn set_ex_data<T>(&mut self, index: Index<SslContext, T>, data: T) {
         unsafe {
-            self.ctx.set_ex_data(index, data);
+            self.ctx.replace_ex_data(index, data);
         }
     }
 
     /// Sets or overwrites the extra data at the specified index.
     ///
     /// This can be used to provide data to callbacks registered with the context. Use the
-    /// `Ssl::new_ex_index` method to create an `Index`.
+    /// `SslContext::new_ex_index` method to create an `Index`.
     ///
     /// Any previous value will be returned and replaced by the new one.
     #[corresponds(SSL_CTX_set_ex_data)]
@@ -1969,8 +1944,10 @@ impl SslContextBuilder {
     pub fn set_sigalgs_list(&mut self, sigalgs: &str) -> Result<(), ErrorStack> {
         let sigalgs = CString::new(sigalgs).map_err(ErrorStack::internal_error)?;
         unsafe {
-            cvt(ffi::SSL_CTX_set1_sigalgs_list(self.as_ptr(), sigalgs.as_ptr()) as c_int)
-                .map(|_| ())
+            cvt(ffi::SSL_CTX_set1_sigalgs_list(
+                self.as_ptr(),
+                sigalgs.as_ptr(),
+            ))
         }
     }
 
@@ -1980,90 +1957,6 @@ impl SslContextBuilder {
         unsafe { ffi::SSL_CTX_set_grease_enabled(self.as_ptr(), enabled as _) }
     }
 
-    /// Sets whether the context should enable record size limit.
-    #[corresponds(SSL_CTX_set_record_size_limit)]
-    pub fn set_record_size_limit(&mut self, limit: u16) {
-        unsafe { ffi::SSL_CTX_set_record_size_limit(self.as_ptr(), limit as _) }
-    }
-
-    /// Sets whether the context should enable delegated credentials.
-    #[corresponds(SSL_CTX_set_delegated_credentials)]
-    pub fn set_delegated_credentials(&mut self, sigalgs: &str) -> Result<(), ErrorStack> {
-        let sigalgs = CString::new(sigalgs).unwrap();
-        unsafe {
-            cvt(ffi::SSL_CTX_set_delegated_credentials(self.as_ptr(), sigalgs.as_ptr()) as c_int)
-                .map(|_| ())
-        }
-    }
-
-    /// Sets whether the context should enable there key share extension.
-    #[corresponds(SSL_CTX_set_key_shares_limit)]
-    pub fn set_key_shares_limit(&mut self, limit: u8) {
-        unsafe { ffi::SSL_CTX_set_key_shares_limit(self.as_ptr(), limit as _) }
-    }
-
-    /// Sets whether the aes hardware override should be enabled.
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_CTX_set_aes_hw_override)]
-    pub fn set_aes_hw_override(&mut self, enable: bool) {
-        unsafe { ffi::SSL_CTX_set_aes_hw_override(self.as_ptr(), enable as _) }
-    }
-
-    /// Sets whether to preserve the TLS 1.3 cipher list as configured by [`Self::set_cipher_list`].
-    ///
-    /// By default, BoringSSL does not preserve the TLS 1.3 cipher list. When this option is disabled
-    /// (the default), BoringSSL uses its internal default TLS 1.3 cipher suites in its default order,
-    /// regardless of what is set via [`Self::set_cipher_list`].
-    ///
-    /// When enabled, this option ensures that the TLS 1.3 cipher suites explicitly set via
-    /// [`Self::set_cipher_list`] are retained in their original order, without being reordered or
-    /// modified by BoringSSL's internal logic. This is useful for maintaining specific cipher suite
-    /// priorities for TLS 1.3. Note that if [`Self::set_cipher_list`] does not include any TLS 1.3
-    /// cipher suites, BoringSSL will still fall back to its default TLS 1.3 cipher suites and order.
-    ///
-    /// This feature isn't available in the certified version of BoringSSL.
-    ///
-    /// # Note
-    ///
-    /// This method must be called **before** [`Self::set_cipher_list`] to take effect.
-    /// If called after [`Self::set_cipher_list`], the setting will be ignored.
-    ///
-    /// [`Self::set_cipher_list`]: #method.set_cipher_list
-    #[cfg(not(feature = "fips"))]
-    #[corresponds(SSL_CTX_set_preserve_tls13_cipher_list)]
-    pub fn set_preserve_tls13_cipher_list(&mut self, enable: bool) {
-        unsafe { ffi::SSL_CTX_set_preserve_tls13_cipher_list(self.as_ptr(), enable as _) }
-    }
-
-    /// Sets whether the ChaCha20 preference should be enabled.
-    ///
-    /// Controls the priority of TLS 1.3 cipher suites. When set to `true`, the client prefers:
-    /// AES_128_GCM, CHACHA20_POLY1305, then AES_256_GCM. Useful in environments with specific
-    /// encryption requirements.
-    #[cfg(not(feature = "fips"))]
-    #[deprecated(note = "use `set_preserve_tls13_cipher_list` instead")]
-    #[corresponds(SSL_CTX_set_prefer_chacha20)]
-    pub fn set_prefer_chacha20(&mut self, enable: bool) {
-        unsafe { ffi::SSL_CTX_set_preserve_tls13_cipher_list(self.as_ptr(), enable as _) }
-    }
-
-    /// Sets the indices of the extensions to be permuted.
-    #[corresponds(SSL_CTX_set_extension_order)]
-    #[cfg(not(feature = "fips-compat"))]
-    pub fn set_extension_permutation(
-        &mut self,
-        indices: &[ExtensionType],
-    ) -> Result<(), ErrorStack> {
-        unsafe {
-            cvt(ffi::SSL_CTX_set_extension_order(
-                self.as_ptr(),
-                indices.as_ptr() as *const _,
-                indices.len() as _,
-            ))
-            .map(|_| ())
-        }
-    }
-
     /// Configures whether ClientHello extensions should be permuted.
     #[corresponds(SSL_CTX_set_permute_extensions)]
     pub fn set_permute_extensions(&mut self, enabled: bool) {
@@ -2079,7 +1972,7 @@ impl SslContextBuilder {
         unsafe {
             cvt_0i(ffi::SSL_CTX_set_verify_algorithm_prefs(
                 self.as_ptr(),
-                prefs.as_ptr() as *const _,
+                prefs.as_ptr().cast(),
                 prefs.len(),
             ))
             .map(|_| ())
@@ -2105,7 +1998,7 @@ impl SslContextBuilder {
         unsafe {
             cvt_0i(ffi::SSL_CTX_set1_curves_list(
                 self.as_ptr(),
-                curves.as_ptr() as *const _,
+                curves.as_ptr(),
             ))
             .map(|_| ())
         }
@@ -2137,7 +2030,37 @@ impl SslContextBuilder {
     /// threads.
     #[corresponds(SSL_CTX_set1_ech_keys)]
     pub fn set_ech_keys(&self, keys: &SslEchKeys) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_set1_ech_keys(self.as_ptr(), keys.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_set1_ech_keys(self.as_ptr(), keys.as_ptr())) }
+    }
+
+    /// Adds a credential.
+    #[corresponds(SSL_CTX_add1_credential)]
+    pub fn add_credential(&mut self, credential: &SslCredentialRef) -> Result<(), ErrorStack> {
+        unsafe {
+            cvt_0i(ffi::SSL_CTX_add1_credential(
+                self.as_ptr(),
+                credential.as_ptr(),
+            ))
+            .map(|_| ())
+        }
+    }
+
+    /// Sets the list of server certificate types that clients attached to this context
+    /// can process.
+    #[corresponds(SSL_CTX_set_server_certificate_types)]
+    #[cfg(feature = "rpk")]
+    pub fn set_server_certificate_types(
+        &mut self,
+        types: &[CertificateType],
+    ) -> Result<(), ErrorStack> {
+        unsafe {
+            cvt_0i(ffi::SSL_CTX_set_server_certificate_types(
+                self.as_ptr(),
+                types.as_ptr() as *const u8,
+                types.len(),
+            ))
+            .map(|_| ())
+        }
     }
 
     /// Consumes the builder, returning a new `SslContext`.
@@ -2243,8 +2166,7 @@ impl SslContextRef {
     #[corresponds(SSL_CTX_get0_certificate)]
     #[must_use]
     pub fn certificate(&self) -> Option<&X509Ref> {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk(), "This API is not supported for RPK");
+        self.check_x509();
 
         unsafe {
             let ptr = ffi::SSL_CTX_get0_certificate(self.as_ptr());
@@ -2274,8 +2196,7 @@ impl SslContextRef {
     #[corresponds(SSL_CTX_get_cert_store)]
     #[must_use]
     pub fn cert_store(&self) -> &X509StoreRef {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk(), "This API is not supported for RPK");
+        self.check_x509();
 
         unsafe { X509StoreRef::from_ptr(ffi::SSL_CTX_get_cert_store(self.as_ptr())) }
     }
@@ -2310,12 +2231,9 @@ impl SslContextRef {
     // this only from SslContextBuilder.
     #[corresponds(SSL_CTX_get_ex_data)]
     unsafe fn ex_data_mut<T>(&mut self, index: Index<SslContext, T>) -> Option<&mut T> {
-        let data = ffi::SSL_CTX_get_ex_data(self.as_ptr(), index.as_raw());
-        if data.is_null() {
-            None
-        } else {
-            Some(&mut *(data as *mut T))
-        }
+        ffi::SSL_CTX_get_ex_data(self.as_ptr(), index.as_raw())
+            .cast::<T>()
+            .as_mut()
     }
 
     // Unsafe because SSL contexts are not guaranteed to be unique, we call
@@ -2323,8 +2241,8 @@ impl SslContextRef {
     #[corresponds(SSL_CTX_set_ex_data)]
     unsafe fn set_ex_data<T>(&mut self, index: Index<SslContext, T>, data: T) {
         unsafe {
-            let data = Box::into_raw(Box::new(data)) as *mut c_void;
-            ffi::SSL_CTX_set_ex_data(self.as_ptr(), index.as_raw(), data);
+            let data = Box::into_raw(Box::new(data));
+            ffi::SSL_CTX_set_ex_data(self.as_ptr(), index.as_raw(), data.cast());
         }
     }
 
@@ -2385,17 +2303,35 @@ impl SslContextRef {
     #[corresponds(SSL_CTX_get_verify_mode)]
     #[must_use]
     pub fn verify_mode(&self) -> SslVerifyMode {
-        #[cfg(feature = "rpk")]
-        assert!(!self.is_rpk(), "This API is not supported for RPK");
+        self.check_x509();
 
         let mode = unsafe { ffi::SSL_CTX_get_verify_mode(self.as_ptr()) };
         SslVerifyMode::from_bits(mode).expect("SSL_CTX_get_verify_mode returned invalid mode")
     }
 
-    /// Returns `true` if context was created for Raw Public Key verification
-    #[cfg(feature = "rpk")]
-    pub fn is_rpk(&self) -> bool {
-        self.ex_data(*RPK_FLAG_INDEX).copied().unwrap_or_default()
+    /// Assumes that this `SslContext` is configured for X.509 certificates.
+    ///
+    /// # Safety
+    ///
+    /// BoringSSL will crash if the user calls a function that involves
+    /// X.509 certificates with an object configured with this method.
+    /// You most probably don't need it.
+    pub unsafe fn assume_x509(&mut self) {
+        self.replace_ex_data(*X509_FLAG_INDEX, true);
+    }
+
+    /// Returns `true` if context is configured for X.509 certificates.
+    #[must_use]
+    pub fn has_x509_support(&self) -> bool {
+        self.ex_data(*X509_FLAG_INDEX).copied().unwrap_or_default()
+    }
+
+    #[track_caller]
+    fn check_x509(&self) {
+        assert!(
+            self.has_x509_support(),
+            "This context is not configured for X.509 certificates"
+        );
     }
 
     /// Registers a list of ECH keys on the context. This list should contain new and old
@@ -2404,7 +2340,28 @@ impl SslContextRef {
     /// threads.
     #[corresponds(SSL_CTX_set1_ech_keys)]
     pub fn set_ech_keys(&self, keys: &SslEchKeys) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_CTX_set1_ech_keys(self.as_ptr(), keys.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_CTX_set1_ech_keys(self.as_ptr(), keys.as_ptr())) }
+    }
+
+    /// Returns the list of server certificate types.
+    #[corresponds(SSL_CTX_get0_server_certificate_types)]
+    #[cfg(feature = "rpk")]
+    #[must_use]
+    pub fn server_certificate_types(&self) -> Option<&[CertificateType]> {
+        let mut types = ptr::null();
+        let mut types_len = 0;
+        unsafe {
+            ffi::SSL_CTX_get0_server_certificate_types(self.as_ptr(), &mut types, &mut types_len);
+
+            if types_len == 0 {
+                return None;
+            }
+
+            Some(slice::from_raw_parts(
+                types as *const CertificateType,
+                types_len,
+            ))
+        }
     }
 }
 
@@ -2415,11 +2372,6 @@ impl SslContextRef {
 #[derive(Debug)]
 pub struct GetSessionPendingError;
 
-#[cfg(not(feature = "legacy-compat-deprecated"))]
-type ProtosLen = usize;
-#[cfg(feature = "legacy-compat-deprecated")]
-type ProtosLen = libc::c_uint;
-
 /// Information about the state of a cipher.
 pub struct CipherBits {
     /// The number of secret bits used for the cipher.
@@ -2496,7 +2448,8 @@ impl ClientHello<'_> {
 }
 
 /// Information about a cipher.
-pub struct SslCipher(*mut ffi::SSL_CIPHER);
+#[derive(Clone, Copy)]
+pub struct SslCipher(&'static SslCipherRef);
 
 impl SslCipher {
     #[corresponds(SSL_get_cipher_by_value)]
@@ -2507,7 +2460,7 @@ impl SslCipher {
             if ptr.is_null() {
                 None
             } else {
-                Some(Self::from_ptr(ptr as *mut ffi::SSL_CIPHER))
+                Some(Self::from_ptr(ptr.cast_mut()))
             }
         }
     }
@@ -2523,12 +2476,12 @@ unsafe impl ForeignType for SslCipher {
 
     #[inline]
     unsafe fn from_ptr(ptr: *mut ffi::SSL_CIPHER) -> SslCipher {
-        SslCipher(ptr)
+        SslCipher(SslCipherRef::from_ptr(ptr))
     }
 
     #[inline]
     fn as_ptr(&self) -> *mut ffi::SSL_CIPHER {
-        self.0
+        self.0.as_ptr()
     }
 }
 
@@ -2536,13 +2489,7 @@ impl Deref for SslCipher {
     type Target = SslCipherRef;
 
     fn deref(&self) -> &SslCipherRef {
-        unsafe { SslCipherRef::from_ptr(self.0) }
-    }
-}
-
-impl DerefMut for SslCipher {
-    fn deref_mut(&mut self) -> &mut SslCipherRef {
-        unsafe { SslCipherRef::from_ptr_mut(self.0) }
+        self.0
     }
 }
 
@@ -2551,11 +2498,21 @@ impl DerefMut for SslCipher {
 /// [`SslCipher`]: struct.SslCipher.html
 pub struct SslCipherRef(Opaque);
 
+unsafe impl Send for SslCipherRef {}
+unsafe impl Sync for SslCipherRef {}
+
 unsafe impl ForeignTypeRef for SslCipherRef {
     type CType = ffi::SSL_CIPHER;
 }
 
 impl SslCipherRef {
+    /// Returns the IANA number of the cipher.
+    #[corresponds(SSL_CIPHER_get_protocol_id)]
+    #[must_use]
+    pub fn protocol_id(&self) -> u16 {
+        unsafe { ffi::SSL_CIPHER_get_protocol_id(self.as_ptr()) }
+    }
+
     /// Returns the name of the cipher.
     #[corresponds(SSL_CIPHER_get_name)]
     #[must_use]
@@ -2586,7 +2543,7 @@ impl SslCipherRef {
     pub fn version(&self) -> &'static str {
         let version = unsafe {
             let ptr = ffi::SSL_CIPHER_get_version(self.as_ptr());
-            CStr::from_ptr(ptr as *const _)
+            CStr::from_ptr(ptr)
         };
 
         version.to_str().unwrap()
@@ -2615,7 +2572,7 @@ impl SslCipherRef {
             // SSL_CIPHER_description requires a buffer of at least 128 bytes.
             let mut buf = [0; 128];
             let ptr = ffi::SSL_CIPHER_description(self.as_ptr(), buf.as_mut_ptr(), 128);
-            CStr::from_ptr(ptr.cast()).to_string_lossy().into_owned()
+            CStr::from_ptr(ptr).to_string_lossy().into_owned()
         }
     }
 
@@ -2864,20 +2821,20 @@ impl Ssl {
     where
         S: Read + Write,
     {
-        #[cfg(feature = "rpk")]
-        {
-            let ctx = self.ssl_context();
-
-            if ctx.is_rpk() {
-                unsafe {
-                    ffi::SSL_CTX_set_custom_verify(
-                        ctx.as_ptr(),
-                        SslVerifyMode::PEER.bits(),
-                        Some(rpk_verify_failure_callback),
-                    );
-                }
-            }
-        }
+        // #[cfg(feature = "rpk")]
+        // {
+        //     let ctx = self.ssl_context();
+
+        //     if !ctx.has_x509_support() {
+        //         unsafe {
+        //             ffi::SSL_CTX_set_custom_verify(
+        //                 ctx.as_ptr(),
+        //                 SslVerifyMode::PEER.bits(),
+        //                 Some(rpk_verify_failure_callback),
+        //             );
+        //         }
+        //     }
+        // }
 
         SslStreamBuilder::new(self, stream).setup_accept()
     }
@@ -2907,8 +2864,7 @@ impl fmt::Debug for SslRef {
 
         builder.field("state", &self.state_string_long());
 
-        #[cfg(feature = "rpk")]
-        if !self.ssl_context().is_rpk() {
+        if self.ssl_context().has_x509_support() {
             builder.field("verify_result", &self.verify_result());
         }
 
@@ -2946,13 +2902,7 @@ impl SslRef {
     #[corresponds(SSL_set1_curves_list)]
     pub fn set_curves_list(&mut self, curves: &str) -> Result<(), ErrorStack> {
         let curves = CString::new(curves).map_err(ErrorStack::internal_error)?;
-        unsafe {
-            cvt_0i(ffi::SSL_set1_curves_list(
-                self.as_ptr(),
-                curves.as_ptr() as *const _,
-            ))
-            .map(|_| ())
-        }
+        unsafe { cvt_0i(ffi::SSL_set1_curves_list(self.as_ptr(), curves.as_ptr())).map(|_| ()) }
     }
 
     /// Returns the curve ID (aka group ID) used for this `SslRef`.
@@ -2994,13 +2944,9 @@ impl SslRef {
     /// [`SslContextBuilder::set_verify`]: struct.SslContextBuilder.html#method.set_verify
     #[corresponds(SSL_set_verify)]
     pub fn set_verify(&mut self, mode: SslVerifyMode) {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
-        unsafe { ffi::SSL_set_verify(self.as_ptr(), mode.bits() as c_int, None) }
+        unsafe { ffi::SSL_set_verify(self.as_ptr(), c_int::from(mode.bits()), None) }
     }
 
     /// Sets the certificate verification depth.
@@ -3008,11 +2954,7 @@ impl SslRef {
     /// If the peer's certificate chain is longer than this value, verification will fail.
     #[corresponds(SSL_set_verify_depth)]
     pub fn set_verify_depth(&mut self, depth: u32) {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             ffi::SSL_set_verify_depth(self.as_ptr(), depth as c_int);
@@ -3023,11 +2965,7 @@ impl SslRef {
     #[corresponds(SSL_get_verify_mode)]
     #[must_use]
     pub fn verify_mode(&self) -> SslVerifyMode {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         let mode = unsafe { ffi::SSL_get_verify_mode(self.as_ptr()) };
         SslVerifyMode::from_bits(mode).expect("SSL_get_verify_mode returned invalid mode")
@@ -3054,18 +2992,14 @@ impl SslRef {
     where
         F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             // this needs to be in an Arc since the callback can register a new callback!
             self.replace_ex_data(Ssl::cached_ex_index(), Arc::new(callback));
             ffi::SSL_set_verify(
                 self.as_ptr(),
-                mode.bits() as c_int,
+                c_int::from(mode.bits()),
                 Some(ssl_raw_verify::<F>),
             );
         }
@@ -3074,15 +3008,13 @@ impl SslRef {
     /// Sets a custom certificate store for verifying peer certificates.
     #[corresponds(SSL_set0_verify_cert_store)]
     pub fn set_verify_cert_store(&mut self, cert_store: X509Store) -> Result<(), ErrorStack> {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
-            cvt(ffi::SSL_set0_verify_cert_store(self.as_ptr(), cert_store.into_ptr()) as c_int)?;
-            Ok(())
+            cvt(ffi::SSL_set0_verify_cert_store(
+                self.as_ptr(),
+                cert_store.into_ptr(),
+            ))
         }
     }
 
@@ -3096,18 +3028,14 @@ impl SslRef {
     where
         F: Fn(&mut SslRef) -> Result<(), SslVerifyError> + 'static + Sync + Send,
     {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             // this needs to be in an Arc since the callback can register a new callback!
             self.replace_ex_data(Ssl::cached_ex_index(), Arc::new(callback));
             ffi::SSL_set_custom_verify(
                 self.as_ptr(),
-                mode.bits() as c_int,
+                c_int::from(mode.bits()),
                 Some(ssl_raw_custom_verify::<F>),
             );
         }
@@ -3118,7 +3046,7 @@ impl SslRef {
     /// [`SslContextBuilder::set_tmp_dh`]: struct.SslContextBuilder.html#method.set_tmp_dh
     #[corresponds(SSL_set_tmp_dh)]
     pub fn set_tmp_dh(&mut self, dh: &DhRef<Params>) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_set_tmp_dh(self.as_ptr(), dh.as_ptr()) as c_int).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_set_tmp_dh(self.as_ptr(), dh.as_ptr())) }
     }
 
     /// Like [`SslContextBuilder::set_tmp_ecdh`].
@@ -3126,7 +3054,7 @@ impl SslRef {
     /// [`SslContextBuilder::set_tmp_ecdh`]: struct.SslContextBuilder.html#method.set_tmp_ecdh
     #[corresponds(SSL_set_tmp_ecdh)]
     pub fn set_tmp_ecdh(&mut self, key: &EcKeyRef<Params>) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_set_tmp_ecdh(self.as_ptr(), key.as_ptr()) as c_int).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_set_tmp_ecdh(self.as_ptr(), key.as_ptr())) }
     }
 
     /// Configures whether ClientHello extensions should be permuted.
@@ -3141,17 +3069,10 @@ impl SslRef {
     #[corresponds(SSL_set_alpn_protos)]
     pub fn set_alpn_protos(&mut self, protocols: &[u8]) -> Result<(), ErrorStack> {
         unsafe {
-            #[cfg_attr(
-                not(feature = "legacy-compat-deprecated"),
-                allow(clippy::unnecessary_cast)
-            )]
-            {
-                assert!(protocols.len() <= ProtosLen::MAX as usize);
-            }
             let r = ffi::SSL_set_alpn_protos(
                 self.as_ptr(),
                 protocols.as_ptr(),
-                protocols.len() as ProtosLen,
+                try_int(protocols.len())?,
             );
             // fun fact, SSL_set_alpn_protos has a reversed return code D:
             if r == 0 {
@@ -3182,7 +3103,7 @@ impl SslRef {
             if ptr.is_null() {
                 None
             } else {
-                Some(SslCipherRef::from_ptr(ptr as *mut _))
+                Some(SslCipherRef::from_ptr(ptr.cast_mut()))
             }
         }
     }
@@ -3195,7 +3116,7 @@ impl SslRef {
     pub fn state_string(&self) -> &'static str {
         let state = unsafe {
             let ptr = ffi::SSL_state_string(self.as_ptr());
-            CStr::from_ptr(ptr as *const _)
+            CStr::from_ptr(ptr)
         };
 
         state.to_str().unwrap_or_default()
@@ -3209,7 +3130,7 @@ impl SslRef {
     pub fn state_string_long(&self) -> &'static str {
         let state = unsafe {
             let ptr = ffi::SSL_state_string_long(self.as_ptr());
-            CStr::from_ptr(ptr as *const _)
+            CStr::from_ptr(ptr)
         };
 
         state.to_str().unwrap_or_default()
@@ -3221,21 +3142,14 @@ impl SslRef {
     #[corresponds(SSL_set_tlsext_host_name)]
     pub fn set_hostname(&mut self, hostname: &str) -> Result<(), ErrorStack> {
         let cstr = CString::new(hostname).map_err(ErrorStack::internal_error)?;
-        unsafe {
-            cvt(ffi::SSL_set_tlsext_host_name(self.as_ptr(), cstr.as_ptr() as *mut _) as c_int)
-                .map(|_| ())
-        }
+        unsafe { cvt(ffi::SSL_set_tlsext_host_name(self.as_ptr(), cstr.as_ptr())) }
     }
 
     /// Returns the peer's certificate, if present.
     #[corresponds(SSL_get_peer_certificate)]
     #[must_use]
     pub fn peer_certificate(&self) -> Option<X509> {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             let ptr = ffi::SSL_get_peer_certificate(self.as_ptr());
@@ -3251,14 +3165,10 @@ impl SslRef {
     ///
     /// On the client side, the chain includes the leaf certificate, but on the server side it does
     /// not. Fun!
-    #[corresponds(SSL_get_peer_certificate)]
+    #[corresponds(SSL_get_peer_cert_chain)]
     #[must_use]
     pub fn peer_cert_chain(&self) -> Option<&StackRef<X509>> {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             let ptr = ffi::SSL_get_peer_cert_chain(self.as_ptr());
@@ -3274,11 +3184,7 @@ impl SslRef {
     #[corresponds(SSL_get_certificate)]
     #[must_use]
     pub fn certificate(&self) -> Option<&X509Ref> {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe {
             let ptr = ffi::SSL_get_certificate(self.as_ptr());
@@ -3331,7 +3237,7 @@ impl SslRef {
     pub fn version_str(&self) -> &'static str {
         let version = unsafe {
             let ptr = ffi::SSL_get_version(self.as_ptr());
-            CStr::from_ptr(ptr as *const _)
+            CStr::from_ptr(ptr)
         };
 
         version.to_str().unwrap()
@@ -3348,7 +3254,6 @@ impl SslRef {
                 self.as_ptr(),
                 version.map_or(0, |v| v.0 as _),
             ))
-            .map(|_| ())
         }
     }
 
@@ -3362,7 +3267,6 @@ impl SslRef {
                 self.as_ptr(),
                 version.map_or(0, |v| v.0 as _),
             ))
-            .map(|_| ())
         }
     }
 
@@ -3441,7 +3345,7 @@ impl SslRef {
             if chain.is_null() {
                 None
             } else {
-                Some(StackRef::from_ptr(chain as *mut _))
+                Some(StackRef::from_ptr(chain.cast_mut()))
             }
         }
     }
@@ -3458,7 +3362,7 @@ impl SslRef {
             if profile.is_null() {
                 None
             } else {
-                Some(SrtpProtectionProfileRef::from_ptr(profile as *mut _))
+                Some(SrtpProtectionProfileRef::from_ptr(profile.cast_mut()))
             }
         }
     }
@@ -3507,7 +3411,7 @@ impl SslRef {
             if name.is_null() {
                 None
             } else {
-                Some(CStr::from_ptr(name as *const _).to_bytes())
+                Some(CStr::from_ptr(name).to_bytes())
             }
         }
     }
@@ -3517,6 +3421,12 @@ impl SslRef {
     /// It is most commonly used in the Server Name Indication (SNI) callback.
     #[corresponds(SSL_set_SSL_CTX)]
     pub fn set_ssl_context(&mut self, ctx: &SslContextRef) -> Result<(), ErrorStack> {
+        assert_eq!(
+            self.ssl_context().has_x509_support(),
+            ctx.has_x509_support(),
+            "X.509 certificate support in old and new contexts doesn't match",
+        );
+
         unsafe { cvt_p(ffi::SSL_set_SSL_CTX(self.as_ptr(), ctx.as_ptr())).map(|_| ()) }
     }
 
@@ -3533,11 +3443,7 @@ impl SslRef {
     /// Returns a mutable reference to the X509 verification configuration.
     #[corresponds(SSL_get0_param)]
     pub fn verify_param_mut(&mut self) -> &mut X509VerifyParamRef {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe { X509VerifyParamRef::from_ptr_mut(ffi::SSL_get0_param(self.as_ptr())) }
     }
@@ -3550,11 +3456,7 @@ impl SslRef {
     /// Returns the certificate verification result.
     #[corresponds(SSL_get_verify_result)]
     pub fn verify_result(&self) -> X509VerifyResult {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe { X509VerifyError::from_raw(ffi::SSL_get_verify_result(self.as_ptr()) as c_int) }
     }
@@ -3579,9 +3481,7 @@ impl SslRef {
     /// value.
     #[corresponds(SSL_get_client_random)]
     pub fn client_random(&self, buf: &mut [u8]) -> usize {
-        unsafe {
-            ffi::SSL_get_client_random(self.as_ptr(), buf.as_mut_ptr() as *mut c_uchar, buf.len())
-        }
+        unsafe { ffi::SSL_get_client_random(self.as_ptr(), buf.as_mut_ptr(), buf.len()) }
     }
 
     /// Copies the server_random value sent by the server in the TLS handshake into a buffer.
@@ -3590,9 +3490,7 @@ impl SslRef {
     /// value.
     #[corresponds(SSL_get_server_random)]
     pub fn server_random(&self, buf: &mut [u8]) -> usize {
-        unsafe {
-            ffi::SSL_get_server_random(self.as_ptr(), buf.as_mut_ptr() as *mut c_uchar, buf.len())
-        }
+        unsafe { ffi::SSL_get_server_random(self.as_ptr(), buf.as_mut_ptr(), buf.len()) }
     }
 
     /// Derives keying material for application use in accordance to RFC 5705.
@@ -3605,20 +3503,19 @@ impl SslRef {
     ) -> Result<(), ErrorStack> {
         unsafe {
             let (context, contextlen, use_context) = match context {
-                Some(context) => (context.as_ptr() as *const c_uchar, context.len(), 1),
+                Some(context) => (context.as_ptr(), context.len(), 1),
                 None => (ptr::null(), 0, 0),
             };
             cvt(ffi::SSL_export_keying_material(
                 self.as_ptr(),
-                out.as_mut_ptr() as *mut c_uchar,
+                out.as_mut_ptr(),
                 out.len(),
-                label.as_ptr() as *const c_char,
+                label.as_ptr().cast::<c_char>(),
                 label.len(),
                 context,
                 contextlen,
                 use_context,
             ))
-            .map(|_| ())
         }
     }
 
@@ -3634,7 +3531,7 @@ impl SslRef {
     /// with the same `SslContext` as this `Ssl`.
     #[corresponds(SSL_set_session)]
     pub unsafe fn set_session(&mut self, session: &SslSessionRef) -> Result<(), ErrorStack> {
-        cvt(ffi::SSL_set_session(self.as_ptr(), session.as_ptr())).map(|_| ())
+        cvt(ffi::SSL_set_session(self.as_ptr(), session.as_ptr()))
     }
 
     /// Determines if the session provided to `set_session` was successfully reused.
@@ -3648,7 +3545,10 @@ impl SslRef {
     #[corresponds(SSL_set_tlsext_status_type)]
     pub fn set_status_type(&mut self, type_: StatusType) -> Result<(), ErrorStack> {
         unsafe {
-            cvt(ffi::SSL_set_tlsext_status_type(self.as_ptr(), type_.as_raw()) as c_int).map(|_| ())
+            cvt(ffi::SSL_set_tlsext_status_type(
+                self.as_ptr(),
+                type_.as_raw(),
+            ))
         }
     }
 
@@ -3669,18 +3569,15 @@ impl SslRef {
     }
 
     /// Sets the OCSP response to be returned to the client.
-    #[corresponds(SSL_set_tlsext_status_ocsp_resp)]
+    #[corresponds(SSL_set_ocsp_response)]
     pub fn set_ocsp_status(&mut self, response: &[u8]) -> Result<(), ErrorStack> {
         unsafe {
             assert!(response.len() <= c_int::MAX as usize);
-            let p = cvt_p(ffi::OPENSSL_malloc(response.len() as _))?;
-            ptr::copy_nonoverlapping(response.as_ptr(), p as *mut u8, response.len());
-            cvt(ffi::SSL_set_tlsext_status_ocsp_resp(
+            cvt(ffi::SSL_set_ocsp_response(
                 self.as_ptr(),
-                p as *mut c_uchar,
+                response.as_ptr(),
                 response.len(),
-            ) as c_int)
-            .map(|_| ())
+            ))
         }
     }
 
@@ -3702,17 +3599,12 @@ impl SslRef {
     pub fn set_ex_data<T>(&mut self, index: Index<Ssl, T>, data: T) {
         if let Some(old) = self.ex_data_mut(index) {
             *old = data;
-
             return;
         }
 
         unsafe {
-            let data = Box::new(data);
-            ffi::SSL_set_ex_data(
-                self.as_ptr(),
-                index.as_raw(),
-                Box::into_raw(data) as *mut c_void,
-            );
+            let data = Box::into_raw(Box::new(data));
+            ffi::SSL_set_ex_data(self.as_ptr(), index.as_raw(), data.cast());
         }
     }
 
@@ -3751,12 +3643,9 @@ impl SslRef {
     #[corresponds(SSL_get_ex_data)]
     pub fn ex_data_mut<T>(&mut self, index: Index<Ssl, T>) -> Option<&mut T> {
         unsafe {
-            let data = ffi::SSL_get_ex_data(self.as_ptr(), index.as_raw());
-            if data.is_null() {
-                None
-            } else {
-                Some(&mut *(data as *mut T))
-            }
+            ffi::SSL_get_ex_data(self.as_ptr(), index.as_raw())
+                .cast::<T>()
+                .as_mut()
         }
     }
 
@@ -3766,7 +3655,7 @@ impl SslRef {
     /// buffer required.
     #[corresponds(SSL_get_finished)]
     pub fn finished(&self, buf: &mut [u8]) -> usize {
-        unsafe { ffi::SSL_get_finished(self.as_ptr(), buf.as_mut_ptr() as *mut c_void, buf.len()) }
+        unsafe { ffi::SSL_get_finished(self.as_ptr(), buf.as_mut_ptr().cast(), buf.len()) }
     }
 
     /// Copies the contents of the last Finished message received from the peer into the provided
@@ -3776,9 +3665,7 @@ impl SslRef {
     /// buffer required.
     #[corresponds(SSL_get_peer_finished)]
     pub fn peer_finished(&self, buf: &mut [u8]) -> usize {
-        unsafe {
-            ffi::SSL_get_peer_finished(self.as_ptr(), buf.as_mut_ptr() as *mut c_void, buf.len())
-        }
+        unsafe { ffi::SSL_get_peer_finished(self.as_ptr(), buf.as_mut_ptr().cast(), buf.len()) }
     }
 
     /// Determines if the initial handshake has been completed.
@@ -3791,7 +3678,7 @@ impl SslRef {
     /// Sets the MTU used for DTLS connections.
     #[corresponds(SSL_set_mtu)]
     pub fn set_mtu(&mut self, mtu: u32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_set_mtu(self.as_ptr(), mtu as c_uint) as c_int).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_set_mtu(self.as_ptr(), mtu as c_uint)) }
     }
 
     /// Sets the certificate.
@@ -3810,11 +3697,7 @@ impl SslRef {
     /// as trusted by this method.
     #[corresponds(SSL_set_client_CA_list)]
     pub fn set_client_ca_list(&mut self, list: Stack<X509Name>) {
-        #[cfg(feature = "rpk")]
-        assert!(
-            !self.ssl_context().is_rpk(),
-            "This API is not supported for RPK"
-        );
+        self.ssl_context().check_x509();
 
         unsafe { ffi::SSL_set_client_CA_list(self.as_ptr(), list.as_ptr()) }
         mem::forget(list);
@@ -3826,7 +3709,7 @@ impl SslRef {
     where
         T: HasPrivate,
     {
-        unsafe { cvt(ffi::SSL_use_PrivateKey(self.as_ptr(), key.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_use_PrivateKey(self.as_ptr(), key.as_ptr())) }
     }
 
     /// Enables all modes set in `mode` in `SSL`. Returns a bitmask representing the resulting
@@ -3848,7 +3731,7 @@ impl SslRef {
     /// Appends `cert` to the chain associated with the current certificate of `SSL`.
     #[corresponds(SSL_add1_chain_cert)]
     pub fn add_chain_cert(&mut self, cert: &X509Ref) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::SSL_add1_chain_cert(self.as_ptr(), cert.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::SSL_add1_chain_cert(self.as_ptr(), cert.as_ptr())) }
     }
 
     /// Configures `ech_config_list` on `SSL` for offering ECH during handshakes. If the server
@@ -3909,7 +3792,7 @@ impl SslRef {
             if data.is_null() {
                 None
             } else {
-                Some(slice::from_raw_parts(data as *const u8, len))
+                Some(slice::from_raw_parts(data.cast::<u8>(), len))
             }
         }
     }
@@ -3936,6 +3819,75 @@ impl SslRef {
     pub fn set_compliance_policy(&mut self, policy: CompliancePolicy) -> Result<(), ErrorStack> {
         unsafe { cvt_0i(ffi::SSL_set_compliance_policy(self.as_ptr(), policy.0)).map(|_| ()) }
     }
+
+    /// Adds a credential.
+    #[corresponds(SSL_add1_credential)]
+    pub fn add_credential(&mut self, credential: &SslCredentialRef) -> Result<(), ErrorStack> {
+        unsafe { cvt_0i(ffi::SSL_add1_credential(self.as_ptr(), credential.as_ptr())).map(|_| ()) }
+    }
+
+    /// Returns the public key sent by the other peer, `None` if there is no ongoing handshake.
+    #[corresponds(SSL_get0_peer_pubkey)]
+    #[cfg(feature = "rpk")]
+    pub fn peer_pubkey(&self) -> Option<&PKeyRef<Public>> {
+        unsafe {
+            let pubkey = ffi::SSL_get0_peer_pubkey(self.as_ptr());
+
+            if pubkey.is_null() {
+                return None;
+            }
+
+            Some(PKeyRef::from_ptr(pubkey as *mut _))
+        }
+    }
+
+    /// Sets the list of server certificate types that clients attached to this `Ssl`
+    /// can process.
+    #[corresponds(SSL_set_server_certificate_types)]
+    #[cfg(feature = "rpk")]
+    pub fn set_server_certificate_types(
+        &mut self,
+        types: &[CertificateType],
+    ) -> Result<(), ErrorStack> {
+        unsafe {
+            cvt_0i(ffi::SSL_set_server_certificate_types(
+                self.as_ptr(),
+                types.as_ptr() as *const u8,
+                types.len(),
+            ))
+            .map(|_| ())
+        }
+    }
+
+    /// Returns the list of server certificate types.
+    #[corresponds(SSL_get0_server_certificate_types)]
+    #[must_use]
+    #[cfg(feature = "rpk")]
+    pub fn server_certificate_types(&self) -> Option<&[CertificateType]> {
+        let mut types = ptr::null();
+        let mut types_len = 0;
+        unsafe {
+            ffi::SSL_get0_server_certificate_types(self.as_ptr(), &mut types, &mut types_len);
+
+            if types_len == 0 {
+                return None;
+            }
+
+            Some(slice::from_raw_parts(
+                types as *const CertificateType,
+                types_len,
+            ))
+        }
+    }
+
+    /// Returns the server certificate type selected by the server, or `CertificateType::X509`
+    /// if there is no handshake.
+    #[corresponds(SSL_get_server_certificate_type_selected)]
+    #[must_use]
+    #[cfg(feature = "rpk")]
+    pub fn selected_server_certificate_type(&self) -> CertificateType {
+        unsafe { CertificateType(ffi::SSL_get_server_certificate_type_selected(self.as_ptr())) }
+    }
 }
 
 /// An SSL stream midway through the handshake process.
@@ -4478,6 +4430,21 @@ impl<S> SslStreamBuilder<S> {
     }
 }
 
+/// A certificate type.
+#[cfg(feature = "rpk")]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
+#[repr(transparent)]
+pub struct CertificateType(u8);
+
+#[cfg(feature = "rpk")]
+impl CertificateType {
+    /// A X.509 certificate.
+    pub const X509: Self = Self(ffi::TLS_CERTIFICATE_TYPE_X509 as u8);
+
+    /// A raw public key.
+    pub const RAW_PUBLIC_KEY: Self = Self(ffi::TLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY as u8);
+}
+
 /// The result of a shutdown request.
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum ShutdownResult {
@@ -4602,26 +4569,10 @@ pub trait CertificateCompressor: Send + Sync + 'static {
 
 use crate::ffi::{SSL_CTX_up_ref, SSL_SESSION_get_master_key, SSL_SESSION_up_ref, SSL_is_server};
 
-use crate::ffi::{DTLS_method, TLS_client_method, TLS_method, TLS_server_method};
-
-use std::sync::Once;
-
 unsafe fn get_new_idx(f: ffi::CRYPTO_EX_free) -> c_int {
-    // hack around https://rt.openssl.org/Ticket/Display.html?id=3710&user=guest&pass=guest
-    static ONCE: Once = Once::new();
-    ONCE.call_once(|| {
-        ffi::SSL_CTX_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, None);
-    });
-
     ffi::SSL_CTX_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, f)
 }
 
 unsafe fn get_new_ssl_idx(f: ffi::CRYPTO_EX_free) -> c_int {
-    // hack around https://rt.openssl.org/Ticket/Display.html?id=3710&user=guest&pass=guest
-    static ONCE: Once = Once::new();
-    ONCE.call_once(|| {
-        ffi::SSL_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, None);
-    });
-
     ffi::SSL_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, f)
 }
diff --git a/boring/src/ssl/test/ech.rs b/boring/src/ssl/test/ech.rs
index d2797d42..db4d4314 100644
--- a/boring/src/ssl/test/ech.rs
+++ b/boring/src/ssl/test/ech.rs
@@ -40,7 +40,7 @@ fn ech() {
     let (_server, client) = bootstrap_ech(ECH_CONFIG, ECH_KEY, ECH_CONFIG_LIST);
 
     let ssl_stream = client.connect();
-    assert!(ssl_stream.ssl().ech_accepted())
+    assert!(ssl_stream.ssl().ech_accepted());
 }
 
 #[test]
@@ -57,7 +57,7 @@ fn ech_rejection() {
         Some(b"ech.com".to_vec().as_ref())
     );
     assert!(failed_ssl_stream.ssl().get_ech_retry_configs().is_some());
-    assert!(!failed_ssl_stream.ssl().ech_accepted())
+    assert!(!failed_ssl_stream.ssl().ech_accepted());
 }
 
 #[test]
@@ -69,5 +69,5 @@ fn ech_grease() {
     client.ssl().set_enable_ech_grease(true);
 
     let ssl_stream = client.connect();
-    assert!(!ssl_stream.ssl().ech_accepted())
+    assert!(!ssl_stream.ssl().ech_accepted());
 }
diff --git a/boring/src/ssl/test/mod.rs b/boring/src/ssl/test/mod.rs
index c7c78e85..e66d0cc8 100644
--- a/boring/src/ssl/test/mod.rs
+++ b/boring/src/ssl/test/mod.rs
@@ -12,11 +12,11 @@ use crate::hash::MessageDigest;
 use crate::pkey::PKey;
 use crate::srtp::SrtpProfileId;
 use crate::ssl::test::server::Server;
-use crate::ssl::SslVersion;
 use crate::ssl::{
     self, ExtensionType, ShutdownResult, ShutdownState, Ssl, SslAcceptor, SslAcceptorBuilder,
     SslConnector, SslContext, SslFiletype, SslMethod, SslOptions, SslStream, SslVerifyMode,
 };
+use crate::ssl::{HandshakeError, SslVersion};
 use crate::x509::store::X509StoreBuilder;
 use crate::x509::verify::X509CheckFlags;
 use crate::x509::{X509Name, X509};
@@ -417,6 +417,68 @@ fn test_select_cert_alpn_extension() {
     );
 }
 
+#[test]
+fn test_io_retry() {
+    #[derive(Debug)]
+    struct RetryStream {
+        inner: TcpStream,
+        first_read: bool,
+        first_write: bool,
+        first_flush: bool,
+    }
+
+    impl Read for RetryStream {
+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+            if mem::replace(&mut self.first_read, false) {
+                Err(io::Error::new(io::ErrorKind::WouldBlock, "first read"))
+            } else {
+                self.inner.read(buf)
+            }
+        }
+    }
+
+    impl Write for RetryStream {
+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+            if mem::replace(&mut self.first_write, false) {
+                Err(io::Error::new(io::ErrorKind::WouldBlock, "first write"))
+            } else {
+                self.inner.write(buf)
+            }
+        }
+
+        fn flush(&mut self) -> io::Result<()> {
+            if mem::replace(&mut self.first_flush, false) {
+                Err(io::Error::new(io::ErrorKind::WouldBlock, "first flush"))
+            } else {
+                self.inner.flush()
+            }
+        }
+    }
+
+    let server = Server::builder().build();
+
+    let stream = RetryStream {
+        inner: server.connect_tcp(),
+        first_read: true,
+        first_write: true,
+        first_flush: true,
+    };
+
+    let ctx = SslContext::builder(SslMethod::tls()).unwrap();
+    let mut s = match Ssl::new(&ctx.build()).unwrap().connect(stream) {
+        Ok(mut s) => return s.read_exact(&mut [0]).unwrap(),
+        Err(HandshakeError::WouldBlock(s)) => s,
+        Err(_) => panic!("should not fail on setup"),
+    };
+    loop {
+        match s.handshake() {
+            Ok(mut s) => return s.read_exact(&mut [0]).unwrap(),
+            Err(HandshakeError::WouldBlock(mid_s)) => s = mid_s,
+            Err(_) => panic!("should not fail on handshake"),
+        }
+    }
+}
+
 #[test]
 #[should_panic(expected = "blammo")]
 fn write_panic() {
@@ -1010,7 +1072,7 @@ fn test_set_compliance() {
     assert_eq!(ciphers.len(), FIPS_CIPHERS.len());
 
     for cipher in ciphers.into_iter().zip(FIPS_CIPHERS) {
-        assert_eq!(cipher.0.name(), cipher.1)
+        assert_eq!(cipher.0.name(), cipher.1);
     }
 
     let mut ctx = SslContext::builder(SslMethod::tls()).unwrap();
@@ -1029,7 +1091,7 @@ fn test_set_compliance() {
     assert_eq!(ciphers.len(), WPA3_192_CIPHERS.len());
 
     for cipher in ciphers.into_iter().zip(WPA3_192_CIPHERS) {
-        assert_eq!(cipher.0.name(), cipher.1)
+        assert_eq!(cipher.0.name(), cipher.1);
     }
 
     ctx.set_compliance_policy(CompliancePolicy::NONE)
@@ -1092,7 +1154,7 @@ fn test_ssl_set_compliance() {
     assert_eq!(ciphers.len(), FIPS_CIPHERS.len());
 
     for cipher in ciphers.into_iter().zip(FIPS_CIPHERS) {
-        assert_eq!(cipher.0.name(), cipher.1)
+        assert_eq!(cipher.0.name(), cipher.1);
     }
 
     let ctx = SslContext::builder(SslMethod::tls()).unwrap().build();
@@ -1112,92 +1174,52 @@ fn test_ssl_set_compliance() {
     assert_eq!(ciphers.len(), WPA3_192_CIPHERS.len());
 
     for cipher in ciphers.into_iter().zip(WPA3_192_CIPHERS) {
-        assert_eq!(cipher.0.name(), cipher.1)
+        assert_eq!(cipher.0.name(), cipher.1);
     }
 
     ssl.set_compliance_policy(CompliancePolicy::NONE)
         .expect_err("Testing expect err if set compliance policy to NONE");
 }
 
-
 #[test]
-fn set_extension_permutation() {
-    let mut ctx = SslContext::builder(SslMethod::tls()).unwrap();
-    // firefox extension permutation
-    ctx.set_extension_permutation(&[
-        ExtensionType::SERVER_NAME,
-        ExtensionType::EXTENDED_MASTER_SECRET,
-        ExtensionType::RENEGOTIATE,
-        ExtensionType::SUPPORTED_GROUPS,
-        ExtensionType::EC_POINT_FORMATS,
-        ExtensionType::SESSION_TICKET,
-        ExtensionType::APPLICATION_LAYER_PROTOCOL_NEGOTIATION,
-        ExtensionType::STATUS_REQUEST,
-        ExtensionType::DELEGATED_CREDENTIAL,
-        ExtensionType::CERTIFICATE_TIMESTAMP,
-        ExtensionType::KEY_SHARE,
-        ExtensionType::SUPPORTED_VERSIONS,
-        ExtensionType::SIGNATURE_ALGORITHMS,
-        ExtensionType::PSK_KEY_EXCHANGE_MODES,
-        ExtensionType::RECORD_SIZE_LIMIT,
-        ExtensionType::CERT_COMPRESSION,
-        ExtensionType::ENCRYPTED_CLIENT_HELLO,
-    ])
-    .unwrap();
-}
-
-
-#[test]
-fn test_connect_with_set_extension_permutation_client_ctx() {
-    let server = Server::builder();
-    let server = server.build();
-
-    let mut client = server.client();
-    // firefox extension permutation
-    client
-        .ctx()
-        .set_extension_permutation(&[
-            ExtensionType::SERVER_NAME,
-            ExtensionType::EXTENDED_MASTER_SECRET,
-            ExtensionType::RENEGOTIATE,
-            ExtensionType::SUPPORTED_GROUPS,
-            ExtensionType::EC_POINT_FORMATS,
-            ExtensionType::SESSION_TICKET,
-            ExtensionType::APPLICATION_LAYER_PROTOCOL_NEGOTIATION,
-            ExtensionType::STATUS_REQUEST,
-            ExtensionType::DELEGATED_CREDENTIAL,
-            ExtensionType::CERTIFICATE_TIMESTAMP,
-            ExtensionType::KEY_SHARE,
-            ExtensionType::SUPPORTED_VERSIONS,
-            ExtensionType::SIGNATURE_ALGORITHMS,
-            ExtensionType::PSK_KEY_EXCHANGE_MODES,
-            ExtensionType::RECORD_SIZE_LIMIT,
-            ExtensionType::CERT_COMPRESSION,
-            ExtensionType::ENCRYPTED_CLIENT_HELLO,
-        ])
-        .unwrap();
-    let _ = client.connect();
-}
-
-#[test]
-fn test_connect_with_set_extension_permutation_empty_client_ctx() {
-    let server = Server::builder();
-    let server = server.build();
-
-    let mut client = server.client();
-    client.ctx().set_extension_permutation(&[]).unwrap();
-    let _ = client.connect();
-}
-
-#[test]
-fn test_connect_with_set_extension_permutation_server_name_client_ctx() {
-    let server = Server::builder();
-    let server = server.build();
+fn ex_data_drop() {
+    use crate::ssl::SslContextBuilder;
+    use std::sync::atomic::AtomicU32;
+    use std::sync::atomic::Ordering::Relaxed;
+    use std::sync::Arc;
+
+    struct TrackDrop(Arc<AtomicU32>);
+    impl Drop for TrackDrop {
+        fn drop(&mut self) {
+            self.0.fetch_add(1, Relaxed);
+        }
+    }
 
-    let mut client = server.client();
-    client
-        .ctx()
-        .set_extension_permutation(&[ExtensionType::SERVER_NAME])
-        .unwrap();
-    let _ = client.connect();
+    let mut ctx = SslContextBuilder::new(SslMethod::tls()).unwrap();
+    let index = SslContext::new_ex_index().unwrap();
+    let d1 = Arc::new(AtomicU32::new(100));
+    let d2 = Arc::new(AtomicU32::new(200));
+    let d3 = Arc::new(AtomicU32::new(300));
+    ctx.set_ex_data(index, TrackDrop(d1.clone()));
+    assert_eq!(100, d1.load(Relaxed));
+    assert_eq!(200, d2.load(Relaxed));
+    ctx.replace_ex_data(index, TrackDrop(d2.clone()));
+    assert_eq!(101, d1.load(Relaxed));
+    assert_eq!(200, d2.load(Relaxed));
+    ctx.replace_ex_data(index, TrackDrop(d3.clone()));
+    assert_eq!(101, d1.load(Relaxed));
+    assert_eq!(201, d2.load(Relaxed));
+    assert_eq!(300, d3.load(Relaxed));
+    drop(ctx);
+    assert_eq!(101, d1.load(Relaxed));
+    assert_eq!(201, d2.load(Relaxed));
+    assert_eq!(301, d3.load(Relaxed));
+
+    let mut ctx2 = SslContextBuilder::new(SslMethod::tls()).unwrap();
+
+    ctx2.set_ex_data(index, TrackDrop(d1.clone()));
+    ctx2.set_ex_data(index, TrackDrop(d2.clone()));
+    drop(ctx2);
+    assert_eq!(102, d1.load(Relaxed));
+    assert_eq!(202, d2.load(Relaxed));
 }
diff --git a/boring/src/ssl/test/session.rs b/boring/src/ssl/test/session.rs
index 23c0f4d5..97ed8c1c 100644
--- a/boring/src/ssl/test/session.rs
+++ b/boring/src/ssl/test/session.rs
@@ -49,7 +49,7 @@ fn new_get_session_callback() {
         .ctx()
         .set_session_cache_mode(SslSessionCacheMode::SERVER | SslSessionCacheMode::NO_INTERNAL);
     server.ctx().set_new_session_callback(|_, session| {
-        SERVER_SESSION_DER.set(session.to_der().unwrap()).unwrap()
+        SERVER_SESSION_DER.set(session.to_der().unwrap()).unwrap();
     });
     unsafe {
         server.ctx().set_get_session_callback(|_, id| {
@@ -76,7 +76,7 @@ fn new_get_session_callback() {
         .ctx()
         .set_session_cache_mode(SslSessionCacheMode::CLIENT);
     client.ctx().set_new_session_callback(|_, session| {
-        CLIENT_SESSION_DER.set(session.to_der().unwrap()).unwrap()
+        CLIENT_SESSION_DER.set(session.to_der().unwrap()).unwrap();
     });
 
     let client = client.build();
diff --git a/boring/src/ssl/test/session_resumption.rs b/boring/src/ssl/test/session_resumption.rs
index 808abe30..5c65c53c 100644
--- a/boring/src/ssl/test/session_resumption.rs
+++ b/boring/src/ssl/test/session_resumption.rs
@@ -61,7 +61,7 @@ fn custom_callback_success() {
     unsafe {
         server
             .ctx()
-            .set_ticket_key_callback(test_success_tickey_key_callback)
+            .set_ticket_key_callback(test_success_tickey_key_callback);
     };
     let server = server.build();
 
@@ -106,7 +106,7 @@ fn custom_callback_unrecognized_decryption_ticket() {
     unsafe {
         server
             .ctx()
-            .set_ticket_key_callback(test_noop_tickey_key_callback)
+            .set_ticket_key_callback(test_noop_tickey_key_callback);
     };
     let server = server.build();
 
diff --git a/boring/src/stack.rs b/boring/src/stack.rs
index 5a95d98c..622c401e 100644
--- a/boring/src/stack.rs
+++ b/boring/src/stack.rs
@@ -48,7 +48,7 @@ impl<T: Stackable> Drop for Stack<T> {
     fn drop(&mut self) {
         unsafe {
             while self.pop().is_some() {}
-            OPENSSL_sk_free(self.0 as *mut _);
+            OPENSSL_sk_free(self.0.cast());
         }
     }
 }
@@ -58,7 +58,7 @@ impl<T: Stackable> Stack<T> {
         unsafe {
             ffi::init();
             let ptr = cvt_p(OPENSSL_sk_new_null())?;
-            Ok(Stack(ptr as *mut _))
+            Ok(Stack(ptr.cast()))
         }
     }
 }
@@ -132,7 +132,7 @@ impl<T: Stackable> Drop for IntoIter<T> {
     fn drop(&mut self) {
         unsafe {
             for _ in &mut *self {}
-            OPENSSL_sk_free(self.stack as *mut _);
+            OPENSSL_sk_free(self.stack.cast());
         }
     }
 }
@@ -144,7 +144,7 @@ impl<T: Stackable> Iterator for IntoIter<T> {
         unsafe {
             self.idxs
                 .next()
-                .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack as *mut _, i) as *mut _))
+                .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack.cast(), i).cast()))
         }
     }
 
@@ -158,7 +158,7 @@ impl<T: Stackable> DoubleEndedIterator for IntoIter<T> {
         unsafe {
             self.idxs
                 .next_back()
-                .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack as *mut _, i) as *mut _))
+                .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack.cast(), i).cast()))
         }
     }
 }
@@ -176,7 +176,7 @@ unsafe impl<T: Stackable> ForeignTypeRef for StackRef<T> {
 
 impl<T: Stackable> StackRef<T> {
     fn as_stack(&self) -> *mut OPENSSL_STACK {
-        self.as_ptr() as *mut _
+        self.as_ptr().cast()
     }
 
     /// Returns the number of items in the stack.
@@ -234,7 +234,7 @@ impl<T: Stackable> StackRef<T> {
     /// Pushes a value onto the top of the stack.
     pub fn push(&mut self, data: T) -> Result<(), ErrorStack> {
         unsafe {
-            cvt_0(OPENSSL_sk_push(self.as_stack(), data.as_ptr() as *mut _))?;
+            cvt_0(OPENSSL_sk_push(self.as_stack(), data.as_ptr().cast()))?;
             mem::forget(data);
             Ok(())
         }
@@ -247,13 +247,13 @@ impl<T: Stackable> StackRef<T> {
             if ptr.is_null() {
                 None
             } else {
-                Some(T::from_ptr(ptr as *mut _))
+                Some(T::from_ptr(ptr.cast()))
             }
         }
     }
 
     unsafe fn _get(&self, idx: usize) -> *mut T::CType {
-        OPENSSL_sk_value(self.as_stack(), idx) as *mut _
+        OPENSSL_sk_value(self.as_stack(), idx).cast()
     }
 }
 
@@ -323,7 +323,7 @@ impl<'a, T: Stackable> Iterator for Iter<'a, T> {
         unsafe {
             self.idxs
                 .next()
-                .map(|i| T::Ref::from_ptr(OPENSSL_sk_value(self.stack.as_stack(), i) as *mut _))
+                .map(|i| T::Ref::from_ptr(OPENSSL_sk_value(self.stack.as_stack(), i).cast()))
         }
     }
 
@@ -337,7 +337,7 @@ impl<'a, T: Stackable> DoubleEndedIterator for Iter<'a, T> {
         unsafe {
             self.idxs
                 .next_back()
-                .map(|i| T::Ref::from_ptr(OPENSSL_sk_value(self.stack.as_stack(), i) as *mut _))
+                .map(|i| T::Ref::from_ptr(OPENSSL_sk_value(self.stack.as_stack(), i).cast()))
         }
     }
 }
@@ -357,7 +357,7 @@ impl<'a, T: Stackable> Iterator for IterMut<'a, T> {
         unsafe {
             self.idxs
                 .next()
-                .map(|i| T::Ref::from_ptr_mut(OPENSSL_sk_value(self.stack.as_stack(), i) as *mut _))
+                .map(|i| T::Ref::from_ptr_mut(OPENSSL_sk_value(self.stack.as_stack(), i).cast()))
         }
     }
 
@@ -371,7 +371,7 @@ impl<'a, T: Stackable> DoubleEndedIterator for IterMut<'a, T> {
         unsafe {
             self.idxs
                 .next_back()
-                .map(|i| T::Ref::from_ptr_mut(OPENSSL_sk_value(self.stack.as_stack(), i) as *mut _))
+                .map(|i| T::Ref::from_ptr_mut(OPENSSL_sk_value(self.stack.as_stack(), i).cast()))
         }
     }
 }
diff --git a/boring/src/string.rs b/boring/src/string.rs
index 4527f0d7..94b2d48d 100644
--- a/boring/src/string.rs
+++ b/boring/src/string.rs
@@ -1,6 +1,6 @@
 use crate::ffi;
 use foreign_types::ForeignTypeRef;
-use libc::{c_char, c_void};
+use libc::c_char;
 use std::convert::AsRef;
 use std::ffi::CStr;
 use std::fmt;
@@ -83,5 +83,5 @@ impl fmt::Debug for OpensslStringRef {
 }
 
 unsafe fn free(buf: *mut c_char) {
-    crate::ffi::OPENSSL_free(buf as *mut c_void);
+    crate::ffi::OPENSSL_free(buf.cast());
 }
diff --git a/boring/src/symm.rs b/boring/src/symm.rs
index a1346e6e..1604b70b 100644
--- a/boring/src/symm.rs
+++ b/boring/src/symm.rs
@@ -54,14 +54,14 @@
 
 use crate::ffi;
 use foreign_types::ForeignTypeRef;
-use libc::{c_int, c_uint};
 use openssl_macros::corresponds;
 use std::cmp;
+use std::ffi::c_int;
 use std::ptr;
 
 use crate::error::ErrorStack;
 use crate::nid::Nid;
-use crate::{cvt, cvt_p};
+use crate::{cvt, cvt_p, try_int};
 
 #[derive(Copy, Clone)]
 pub enum Mode {
@@ -79,7 +79,7 @@ foreign_type_and_impl_send_sync! {
 impl CipherCtxRef {
     /// Configures CipherCtx for a fresh encryption operation using `cipher`.
     ///
-    /// https://commondatastorage.googleapis.com/chromium-boringssl-docs/cipher.h.html#EVP_EncryptInit_ex
+    #[corresponds(EVP_EncryptInit_ex)]
     pub fn init_encrypt(
         &mut self,
         cipher: &Cipher,
@@ -101,13 +101,12 @@ impl CipherCtxRef {
                 key.as_ptr(),
                 iv.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
     /// Configures CipherCtx for a fresh decryption operation using `cipher`.
     ///
-    /// https://commondatastorage.googleapis.com/chromium-boringssl-docs/cipher.h.html#EVP_DecryptInit_ex
+    #[corresponds(EVP_DecryptInit_ex)]
     pub fn init_decrypt(
         &mut self,
         cipher: &Cipher,
@@ -129,7 +128,6 @@ impl CipherCtxRef {
                 key.as_ptr(),
                 iv.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 }
@@ -139,7 +137,7 @@ impl CipherCtxRef {
 /// See OpenSSL doc at [`EVP_EncryptInit`] for more information on each algorithms.
 ///
 /// [`EVP_EncryptInit`]: https://www.openssl.org/docs/man1.1.0/crypto/EVP_EncryptInit.html
-#[derive(Copy, Clone, PartialEq, Eq)]
+#[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub struct Cipher(*const ffi::EVP_CIPHER);
 
 impl Cipher {
@@ -303,6 +301,14 @@ impl Cipher {
     pub fn block_size(&self) -> usize {
         unsafe { EVP_CIPHER_block_size(self.0) as usize }
     }
+
+    /// Returns the cipher's NID.
+    #[corresponds(EVP_CIPHER_nid)]
+    pub fn nid(&self) -> Nid {
+        ffi::init();
+        let nid = unsafe { ffi::EVP_CIPHER_nid(self.as_ptr()) };
+        Nid::from_raw(nid)
+    }
 }
 
 unsafe impl Sync for Cipher {}
@@ -413,25 +419,22 @@ impl Crypter {
                 mode,
             ))?;
 
-            assert!(key.len() <= c_int::MAX as usize);
             cvt(ffi::EVP_CIPHER_CTX_set_key_length(
                 crypter.ctx,
-                key.len() as c_uint,
+                try_int(key.len())?,
             ))?;
 
-            let key = key.as_ptr() as *mut _;
             let iv = match (iv, t.iv_len()) {
                 (Some(iv), Some(len)) => {
                     if iv.len() != len {
-                        assert!(iv.len() <= c_int::MAX as usize);
                         cvt(ffi::EVP_CIPHER_CTX_ctrl(
                             crypter.ctx,
                             ffi::EVP_CTRL_GCM_SET_IVLEN,
-                            iv.len() as c_int,
+                            try_int(iv.len())?,
                             ptr::null_mut(),
                         ))?;
                     }
-                    iv.as_ptr() as *mut _
+                    iv.as_ptr().cast_mut()
                 }
                 (Some(_) | None, None) => ptr::null_mut(),
                 (None, Some(_)) => panic!("an IV is required for this cipher"),
@@ -440,7 +443,7 @@ impl Crypter {
                 crypter.ctx,
                 ptr::null(),
                 ptr::null_mut(),
-                key,
+                key.as_ptr().cast_mut(),
                 iv,
                 mode,
             ))?;
@@ -464,15 +467,13 @@ impl Crypter {
     /// When decrypting cipher text using an AEAD cipher, this must be called before `finalize`.
     pub fn set_tag(&mut self, tag: &[u8]) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(tag.len() <= c_int::MAX as usize);
             // NB: this constant is actually more general than just GCM.
             cvt(ffi::EVP_CIPHER_CTX_ctrl(
                 self.ctx,
                 ffi::EVP_CTRL_GCM_SET_TAG,
-                tag.len() as c_int,
-                tag.as_ptr() as *mut _,
+                try_int(tag.len())?,
+                tag.as_ptr().cast_mut().cast(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -482,15 +483,13 @@ impl Crypter {
     /// to use a value different than the default 12 bytes.
     pub fn set_tag_len(&mut self, tag_len: usize) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(tag_len <= c_int::MAX as usize);
             // NB: this constant is actually more general than just GCM.
             cvt(ffi::EVP_CIPHER_CTX_ctrl(
                 self.ctx,
                 ffi::EVP_CTRL_GCM_SET_TAG,
-                tag_len as c_int,
+                try_int(tag_len)?,
                 ptr::null_mut(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -500,16 +499,14 @@ impl Crypter {
     /// CCM mode.
     pub fn set_data_len(&mut self, data_len: usize) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(data_len <= c_int::MAX as usize);
             let mut len = 0;
             cvt(ffi::EVP_CipherUpdate(
                 self.ctx,
                 ptr::null_mut(),
                 &mut len,
                 ptr::null_mut(),
-                data_len as c_int,
+                try_int(data_len)?,
             ))
-            .map(|_| ())
         }
     }
 
@@ -520,16 +517,14 @@ impl Crypter {
     /// `update`.
     pub fn aad_update(&mut self, input: &[u8]) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(input.len() <= c_int::MAX as usize);
             let mut len = 0;
             cvt(ffi::EVP_CipherUpdate(
                 self.ctx,
                 ptr::null_mut(),
                 &mut len,
                 input.as_ptr(),
-                input.len() as c_int,
+                try_int(input.len())?,
             ))
-            .map(|_| ())
         }
     }
 
@@ -545,8 +540,6 @@ impl Crypter {
     ///
     /// Panics for block ciphers if `output.len() < input.len() + block_size`,
     /// where `block_size` is the block size of the cipher (see `Cipher::block_size`).
-    ///
-    /// Panics if `output.len() > c_int::MAX`.
     pub fn update(&mut self, input: &[u8], output: &mut [u8]) -> Result<usize, ErrorStack> {
         unsafe {
             let block_size = if self.block_size > 1 {
@@ -555,16 +548,14 @@ impl Crypter {
                 0
             };
             assert!(output.len() >= input.len() + block_size);
-            assert!(output.len() <= c_int::MAX as usize);
-            let mut outl = output.len() as c_int;
-            let inl = input.len() as c_int;
+            let mut outl = try_int(output.len())?;
 
             cvt(ffi::EVP_CipherUpdate(
                 self.ctx,
                 output.as_mut_ptr(),
                 &mut outl,
                 input.as_ptr(),
-                inl,
+                try_int(input.len())?,
             ))?;
 
             Ok(outl as usize)
@@ -609,14 +600,12 @@ impl Crypter {
     /// bytes, for example.
     pub fn get_tag(&self, tag: &mut [u8]) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(tag.len() <= c_int::MAX as usize);
             cvt(ffi::EVP_CIPHER_CTX_ctrl(
                 self.ctx,
                 ffi::EVP_CTRL_GCM_GET_TAG,
-                tag.len() as c_int,
-                tag.as_mut_ptr() as *mut _,
+                try_int(tag.len())?,
+                tag.as_mut_ptr().cast(),
             ))
-            .map(|_| ())
         }
     }
 }
@@ -1051,4 +1040,37 @@ mod tests {
         .unwrap();
         assert_eq!(pt, hex::encode(out));
     }
+
+    #[test]
+    fn test_nid_roundtrip() {
+        for cipher in [
+            Cipher::aes_128_ecb(),
+            Cipher::aes_128_cbc(),
+            Cipher::aes_128_ctr(),
+            Cipher::aes_128_ofb(),
+            Cipher::aes_192_ecb(),
+            Cipher::aes_192_cbc(),
+            Cipher::aes_192_ctr(),
+            Cipher::aes_192_ofb(),
+            Cipher::aes_256_ecb(),
+            Cipher::aes_256_cbc(),
+            Cipher::aes_256_ctr(),
+            Cipher::aes_256_ofb(),
+            Cipher::des_ecb(),
+            Cipher::des_ede3_cbc(),
+            Cipher::des_cbc(),
+            Cipher::rc4(),
+        ] {
+            assert_eq!(Cipher::from_nid(cipher.nid()), Some(cipher));
+        }
+
+        for cipher in [
+            Cipher::aes_128_gcm(),
+            Cipher::aes_192_gcm(),
+            Cipher::aes_256_gcm(),
+            Cipher::des_ede3(),
+        ] {
+            assert_eq!(Cipher::from_nid(cipher.nid()), None);
+        }
+    }
 }
diff --git a/boring/src/util.rs b/boring/src/util.rs
index d34fd898..6583f0aa 100644
--- a/boring/src/util.rs
+++ b/boring/src/util.rs
@@ -46,10 +46,10 @@ pub unsafe extern "C" fn invoke_passwd_cb<F>(
 where
     F: FnOnce(&mut [u8]) -> Result<usize, ErrorStack>,
 {
-    let callback = &mut *(cb_state as *mut CallbackState<F>);
+    let callback = &mut *cb_state.cast::<CallbackState<F>>();
 
     let result = panic::catch_unwind(AssertUnwindSafe(|| {
-        let pass_slice = slice::from_raw_parts_mut(buf as *mut u8, size as usize);
+        let pass_slice = slice::from_raw_parts_mut(buf.cast::<u8>(), size as usize);
         callback.cb.take().unwrap()(pass_slice)
     }));
 
@@ -80,14 +80,14 @@ impl<FT: ForeignType> ForeignTypeExt for FT {}
 
 pub trait ForeignTypeRefExt: ForeignTypeRef {
     unsafe fn from_const_ptr<'a>(ptr: *const Self::CType) -> &'a Self {
-        Self::from_ptr(ptr as *mut Self::CType)
+        Self::from_ptr(ptr.cast_mut())
     }
 
     unsafe fn from_const_ptr_opt<'a>(ptr: *const Self::CType) -> Option<&'a Self> {
         if ptr.is_null() {
             None
         } else {
-            Some(Self::from_const_ptr(ptr as *mut Self::CType))
+            Some(Self::from_const_ptr(ptr.cast_mut()))
         }
     }
 }
diff --git a/boring/src/x509/mod.rs b/boring/src/x509/mod.rs
index cd5d428e..d1087117 100644
--- a/boring/src/x509/mod.rs
+++ b/boring/src/x509/mod.rs
@@ -20,7 +20,7 @@ use std::net::IpAddr;
 use std::path::Path;
 use std::ptr;
 use std::str;
-use std::sync::{LazyLock, Once};
+use std::sync::LazyLock;
 
 use crate::asn1::{
     Asn1BitStringRef, Asn1IntegerRef, Asn1Object, Asn1ObjectRef, Asn1StringRef, Asn1TimeRef,
@@ -36,6 +36,7 @@ use crate::pkey::{HasPrivate, HasPublic, PKey, PKeyRef, Public};
 use crate::ssl::SslRef;
 use crate::stack::{Stack, StackRef, Stackable};
 use crate::string::OpensslString;
+use crate::try_int;
 use crate::util::ForeignTypeRefExt;
 use crate::x509::verify::{X509VerifyParam, X509VerifyParamRef};
 use crate::{cvt, cvt_n, cvt_p};
@@ -105,12 +106,9 @@ impl X509StoreContextRef {
     #[must_use]
     pub fn ex_data<T>(&self, index: Index<X509StoreContext, T>) -> Option<&T> {
         unsafe {
-            let data = ffi::X509_STORE_CTX_get_ex_data(self.as_ptr(), index.as_raw());
-            if data.is_null() {
-                None
-            } else {
-                Some(&*(data as *const T))
-            }
+            ffi::X509_STORE_CTX_get_ex_data(self.as_ptr(), index.as_raw())
+                .cast::<T>()
+                .as_ref()
         }
     }
 
@@ -118,12 +116,9 @@ impl X509StoreContextRef {
     #[corresponds(X509_STORE_CTX_get_ex_data)]
     pub fn ex_data_mut<T>(&mut self, index: Index<X509StoreContext, T>) -> Option<&mut T> {
         unsafe {
-            let data = ffi::X509_STORE_CTX_get_ex_data(self.as_ptr(), index.as_raw());
-            if data.is_null() {
-                None
-            } else {
-                Some(&mut *(data as *mut T))
-            }
+            ffi::X509_STORE_CTX_get_ex_data(self.as_ptr(), index.as_raw())
+                .cast::<T>()
+                .as_mut()
         }
     }
 
@@ -145,7 +140,7 @@ impl X509StoreContextRef {
             ffi::X509_STORE_CTX_set_ex_data(
                 self.as_ptr(),
                 index.as_raw(),
-                Box::into_raw(data) as *mut c_void,
+                Box::into_raw(data).cast(),
             );
         }
     }
@@ -368,13 +363,13 @@ impl X509Builder {
     /// Sets the notAfter constraint on the certificate.
     #[corresponds(X509_set1_notAfter)]
     pub fn set_not_after(&mut self, not_after: &Asn1TimeRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(X509_set1_notAfter(self.0.as_ptr(), not_after.as_ptr())).map(|_| ()) }
+        unsafe { cvt(X509_set1_notAfter(self.0.as_ptr(), not_after.as_ptr())) }
     }
 
     /// Sets the notBefore constraint on the certificate.
     #[corresponds(X509_set1_notBefore)]
     pub fn set_not_before(&mut self, not_before: &Asn1TimeRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(X509_set1_notBefore(self.0.as_ptr(), not_before.as_ptr())).map(|_| ()) }
+        unsafe { cvt(X509_set1_notBefore(self.0.as_ptr(), not_before.as_ptr())) }
     }
 
     /// Sets the version of the certificate.
@@ -383,7 +378,7 @@ impl X509Builder {
     /// the X.509 standard should pass `2` to this method.
     #[corresponds(X509_set_version)]
     pub fn set_version(&mut self, version: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_set_version(self.0.as_ptr(), version.into())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_set_version(self.0.as_ptr(), version.into())) }
     }
 
     /// Sets the serial number of the certificate.
@@ -394,7 +389,6 @@ impl X509Builder {
                 self.0.as_ptr(),
                 serial_number.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -406,7 +400,6 @@ impl X509Builder {
                 self.0.as_ptr(),
                 issuer_name.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -435,7 +428,6 @@ impl X509Builder {
                 self.0.as_ptr(),
                 subject_name.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -445,7 +437,7 @@ impl X509Builder {
     where
         T: HasPublic,
     {
-        unsafe { cvt(ffi::X509_set_pubkey(self.0.as_ptr(), key.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_set_pubkey(self.0.as_ptr(), key.as_ptr())) }
     }
 
     /// Returns a context object which is needed to create certain X509 extension values.
@@ -499,7 +491,7 @@ impl X509Builder {
     where
         T: HasPrivate,
     {
-        unsafe { cvt(ffi::X509_sign(self.0.as_ptr(), key.as_ptr(), hash.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_sign(self.0.as_ptr(), key.as_ptr(), hash.as_ptr())) }
     }
 
     /// Consumes the builder, returning the certificate.
@@ -549,7 +541,7 @@ impl X509Ref {
             if stack.is_null() {
                 None
             } else {
-                Some(Stack::from_ptr(stack as *mut _))
+                Some(Stack::from_ptr(stack.cast()))
             }
         }
     }
@@ -578,7 +570,7 @@ impl X509Ref {
             if stack.is_null() {
                 None
             } else {
-                Some(Stack::from_ptr(stack as *mut _))
+                Some(Stack::from_ptr(stack.cast()))
             }
         }
     }
@@ -619,14 +611,14 @@ impl X509Ref {
                 buf: [0; ffi::EVP_MAX_MD_SIZE as usize],
                 len: ffi::EVP_MAX_MD_SIZE as usize,
             };
-            let mut len = ffi::EVP_MAX_MD_SIZE.try_into().unwrap();
+            let mut len = try_int(ffi::EVP_MAX_MD_SIZE)?;
             cvt(ffi::X509_digest(
                 self.as_ptr(),
                 hash_type.as_ptr(),
-                digest.buf.as_mut_ptr() as *mut _,
+                digest.buf.as_mut_ptr(),
                 &mut len,
             ))?;
-            digest.len = len as usize;
+            digest.len = try_int(len)?;
 
             Ok(digest)
         }
@@ -667,7 +659,7 @@ impl X509Ref {
             let mut signature = ptr::null();
             X509_get0_signature(&mut signature, ptr::null_mut(), self.as_ptr());
             assert!(!signature.is_null());
-            Asn1BitStringRef::from_ptr(signature as *mut _)
+            Asn1BitStringRef::from_ptr(signature.cast_mut())
         }
     }
 
@@ -679,7 +671,7 @@ impl X509Ref {
             let mut algor = ptr::null();
             X509_get0_signature(ptr::null_mut(), &mut algor, self.as_ptr());
             assert!(!algor.is_null());
-            X509AlgorithmRef::from_ptr(algor as *mut _)
+            X509AlgorithmRef::from_ptr(algor.cast_mut())
         }
     }
 
@@ -728,7 +720,7 @@ impl X509Ref {
         unsafe {
             cvt_n(ffi::X509_check_host(
                 self.as_ptr(),
-                host.as_ptr() as _,
+                host.as_ptr().cast(),
                 host.len(),
                 0,
                 std::ptr::null_mut(),
@@ -880,7 +872,7 @@ pub struct X509v3Context<'a>(ffi::X509V3_CTX, PhantomData<(&'a X509Ref, &'a Conf
 impl X509v3Context<'_> {
     #[must_use]
     pub fn as_ptr(&self) -> *mut ffi::X509V3_CTX {
-        &self.0 as *const _ as *mut _
+        std::ptr::addr_of!(self.0).cast_mut()
     }
 }
 
@@ -935,8 +927,8 @@ impl X509Extension {
                     &mut ctx
                 }
             };
-            let name = name.as_ptr() as *mut _;
-            let value = value.as_ptr() as *mut _;
+            let name = name.as_ptr().cast_mut();
+            let value = value.as_ptr().cast_mut();
 
             cvt_p(ffi::X509V3_EXT_nconf(conf, context_ptr, name, value))
                 .map(|p| X509Extension::from_ptr(p))
@@ -981,7 +973,7 @@ impl X509Extension {
                 }
             };
             let name = name.as_raw();
-            let value = value.as_ptr() as *mut _;
+            let value = value.as_ptr().cast_mut();
 
             cvt_p(ffi::X509V3_EXT_nconf_nid(conf, context_ptr, name, value))
                 .map(|p| X509Extension::from_ptr(p))
@@ -1024,17 +1016,15 @@ impl X509NameBuilder {
     pub fn append_entry_by_text(&mut self, field: &str, value: &str) -> Result<(), ErrorStack> {
         unsafe {
             let field = CString::new(field).map_err(ErrorStack::internal_error)?;
-            assert!(value.len() <= ValueLen::MAX as usize);
             cvt(ffi::X509_NAME_add_entry_by_txt(
                 self.0.as_ptr(),
-                field.as_ptr() as *mut _,
+                field.as_ptr().cast_mut(),
                 ffi::MBSTRING_UTF8,
                 value.as_ptr(),
-                value.len() as ValueLen,
+                try_int(value.len())?,
                 -1,
                 0,
             ))
-            .map(|_| ())
         }
     }
 
@@ -1048,17 +1038,15 @@ impl X509NameBuilder {
     ) -> Result<(), ErrorStack> {
         unsafe {
             let field = CString::new(field).map_err(ErrorStack::internal_error)?;
-            assert!(value.len() <= ValueLen::MAX as usize);
             cvt(ffi::X509_NAME_add_entry_by_txt(
                 self.0.as_ptr(),
-                field.as_ptr() as *mut _,
+                field.as_ptr().cast_mut(),
                 ty.as_raw(),
                 value.as_ptr(),
-                value.len() as ValueLen,
+                try_int(value.len())?,
                 -1,
                 0,
             ))
-            .map(|_| ())
         }
     }
 
@@ -1066,17 +1054,15 @@ impl X509NameBuilder {
     #[corresponds(X509_NAME_add_entry_by_NID)]
     pub fn append_entry_by_nid(&mut self, field: Nid, value: &str) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(value.len() <= ValueLen::MAX as usize);
             cvt(ffi::X509_NAME_add_entry_by_NID(
                 self.0.as_ptr(),
                 field.as_raw(),
                 ffi::MBSTRING_UTF8,
-                value.as_ptr() as *mut _,
-                value.len() as ValueLen,
+                value.as_ptr().cast_mut(),
+                try_int(value.len())?,
                 -1,
                 0,
             ))
-            .map(|_| ())
         }
     }
 
@@ -1089,17 +1075,15 @@ impl X509NameBuilder {
         ty: Asn1Type,
     ) -> Result<(), ErrorStack> {
         unsafe {
-            assert!(value.len() <= ValueLen::MAX as usize);
             cvt(ffi::X509_NAME_add_entry_by_NID(
                 self.0.as_ptr(),
                 field.as_raw(),
                 ty.as_raw(),
-                value.as_ptr() as *mut _,
-                value.len() as ValueLen,
+                value.as_ptr().cast_mut(),
+                try_int(value.len())?,
                 -1,
                 0,
             ))
-            .map(|_| ())
         }
     }
 
@@ -1113,11 +1097,6 @@ impl X509NameBuilder {
     }
 }
 
-#[cfg(not(feature = "legacy-compat-deprecated"))]
-type ValueLen = isize;
-#[cfg(feature = "legacy-compat-deprecated")]
-type ValueLen = i32;
-
 foreign_type_and_impl_send_sync! {
     type CType = ffi::X509_NAME;
     fn drop = ffi::X509_NAME_free;
@@ -1296,7 +1275,7 @@ impl X509ReqBuilder {
     /// Set the numerical value of the version field.
     #[corresponds(X509_REQ_set_version)]
     pub fn set_version(&mut self, version: i32) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_REQ_set_version(self.0.as_ptr(), version.into())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_REQ_set_version(self.0.as_ptr(), version.into())) }
     }
 
     /// Set the issuer name.
@@ -1307,7 +1286,6 @@ impl X509ReqBuilder {
                 self.0.as_ptr(),
                 subject_name.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1317,7 +1295,7 @@ impl X509ReqBuilder {
     where
         T: HasPublic,
     {
-        unsafe { cvt(ffi::X509_REQ_set_pubkey(self.0.as_ptr(), key.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_REQ_set_pubkey(self.0.as_ptr(), key.as_ptr())) }
     }
 
     /// Return an `X509v3Context`. This context object can be used to construct
@@ -1355,7 +1333,6 @@ impl X509ReqBuilder {
                 self.0.as_ptr(),
                 extensions.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1371,7 +1348,6 @@ impl X509ReqBuilder {
                 key.as_ptr(),
                 hash.as_ptr(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -1766,7 +1742,7 @@ impl X509AlgorithmRef {
             let mut oid = ptr::null();
             X509_ALGOR_get0(&mut oid, ptr::null_mut(), ptr::null_mut(), self.as_ptr());
             assert!(!oid.is_null());
-            Asn1ObjectRef::from_ptr(oid as *mut _)
+            Asn1ObjectRef::from_ptr(oid.cast_mut())
         }
     }
 }
@@ -1809,16 +1785,9 @@ use crate::ffi::X509_OBJECT_get0_X509;
 #[allow(bad_style)]
 unsafe fn X509_OBJECT_free(x: *mut ffi::X509_OBJECT) {
     ffi::X509_OBJECT_free_contents(x);
-    ffi::OPENSSL_free(x as *mut libc::c_void);
+    ffi::OPENSSL_free(x.cast());
 }
 
 unsafe fn get_new_x509_store_ctx_idx(f: ffi::CRYPTO_EX_free) -> c_int {
-    // hack around https://rt.openssl.org/Ticket/Display.html?id=3710&user=guest&pass=guest
-    static ONCE: Once = Once::new();
-
-    ONCE.call_once(|| {
-        ffi::X509_STORE_CTX_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, None);
-    });
-
     ffi::X509_STORE_CTX_get_ex_new_index(0, ptr::null_mut(), ptr::null_mut(), None, f)
 }
diff --git a/boring/src/x509/store.rs b/boring/src/x509/store.rs
index 1f6d839b..f4edca03 100644
--- a/boring/src/x509/store.rs
+++ b/boring/src/x509/store.rs
@@ -48,7 +48,7 @@ use crate::x509::{X509Object, X509};
 use crate::{cvt, cvt_p};
 use foreign_types::{ForeignType, ForeignTypeRef};
 use openssl_macros::corresponds;
-use std::mem;
+use std::mem::ManuallyDrop;
 
 foreign_type_and_impl_send_sync! {
     type CType = ffi::X509_STORE;
@@ -73,9 +73,7 @@ impl X509StoreBuilder {
     /// Constructs the `X509Store`.
     #[must_use]
     pub fn build(self) -> X509Store {
-        let store = X509Store(self.0);
-        mem::forget(self);
-        store
+        X509Store(ManuallyDrop::new(self).0)
     }
 }
 
@@ -84,7 +82,7 @@ impl X509StoreBuilderRef {
     // FIXME should take an &X509Ref
     #[corresponds(X509_STORE_add_cert)]
     pub fn add_cert(&mut self, cert: X509) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_STORE_add_cert(self.as_ptr(), cert.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_STORE_add_cert(self.as_ptr(), cert.as_ptr())) }
     }
 
     /// Load certificates from their default locations.
@@ -94,7 +92,7 @@ impl X509StoreBuilderRef {
     /// build time otherwise.
     #[corresponds(X509_STORE_set_default_paths)]
     pub fn set_default_paths(&mut self) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_STORE_set_default_paths(self.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_STORE_set_default_paths(self.as_ptr())) }
     }
 
     /// Sets certificate chain validation related flags.
@@ -114,7 +112,7 @@ impl X509StoreBuilderRef {
     /// Sets certificate chain validation related parameters.
     #[corresponds(X509_STORE_set1_param)]
     pub fn set_param(&mut self, param: &X509VerifyParamRef) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_STORE_set1_param(self.as_ptr(), param.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_STORE_set1_param(self.as_ptr(), param.as_ptr())) }
     }
 
     /// For testing only
@@ -134,6 +132,23 @@ foreign_type_and_impl_send_sync! {
     pub struct X509Store;
 }
 
+impl ToOwned for X509StoreRef {
+    type Owned = X509Store;
+
+    fn to_owned(&self) -> X509Store {
+        unsafe {
+            ffi::X509_STORE_up_ref(self.as_ptr());
+            X509Store::from_ptr(self.as_ptr())
+        }
+    }
+}
+
+impl Clone for X509Store {
+    fn clone(&self) -> X509Store {
+        (**self).to_owned()
+    }
+}
+
 impl X509StoreRef {
     /// **Warning: this method is unsound**
     ///
@@ -160,12 +175,16 @@ impl X509StoreRef {
 }
 
 #[test]
-#[allow(dead_code)]
-// X509Store must not implement Clone because `SslContextBuilder::cert_store_mut` lets
-// you get a mutable reference to a store that could have been cloned before being
-// passed to `SslContextBuilder::set_cert_store`.
-fn no_clone_for_x509store() {
-    trait MustNotImplementClone {}
-    impl<T: Clone> MustNotImplementClone for T {}
-    impl MustNotImplementClone for X509Store {}
+#[allow(clippy::redundant_clone)]
+#[should_panic = "Shared X509Store can't be mutated"]
+fn set_cert_store_pevents_mutability() {
+    use crate::ssl::*;
+
+    let mut ctx = SslContext::builder(SslMethod::tls()).unwrap();
+    let store = X509StoreBuilder::new().unwrap().build();
+
+    ctx.set_cert_store(store.clone());
+
+    // This is bad.
+    let _aliased_store = ctx.cert_store_mut();
 }
diff --git a/boring/src/x509/tests/mod.rs b/boring/src/x509/tests/mod.rs
index 371cd9b6..2a1b3fd5 100644
--- a/boring/src/x509/tests/mod.rs
+++ b/boring/src/x509/tests/mod.rs
@@ -73,7 +73,7 @@ fn test_subject_read_cn() {
     let cert = X509::from_pem(cert).unwrap();
     let subject = cert.subject_name();
     let cn = subject.entries_by_nid(Nid::COMMONNAME).next().unwrap();
-    assert_eq!(cn.data().as_slice(), b"foobar.com")
+    assert_eq!(cn.data().as_slice(), b"foobar.com");
 }
 
 #[test]
diff --git a/boring/src/x509/tests/trusted_first.rs b/boring/src/x509/tests/trusted_first.rs
index 9f49ffe3..ad660a3b 100644
--- a/boring/src/x509/tests/trusted_first.rs
+++ b/boring/src/x509/tests/trusted_first.rs
@@ -2,7 +2,7 @@
 
 use crate::stack::Stack;
 use crate::x509::store::X509StoreBuilder;
-use crate::x509::verify::{X509Flags, X509VerifyParamRef};
+use crate::x509::verify::{X509VerifyFlags, X509VerifyParamRef};
 use crate::x509::{X509Ref, X509StoreContext, X509VerifyError, X509VerifyResult, X509};
 
 #[test]
@@ -43,7 +43,7 @@ fn test_verify_cert() {
             &leaf,
             &[&root1, &root2],
             &[&intermediate, &root1_cross],
-            |param| param.set_flags(X509Flags::TRUSTED_FIRST),
+            |param| param.set_flags(X509VerifyFlags::TRUSTED_FIRST),
         )
     );
 
@@ -53,14 +53,14 @@ fn test_verify_cert() {
             &leaf,
             &[&root1, &root2],
             &[&intermediate, &root1_cross],
-            |param| param.clear_flags(X509Flags::TRUSTED_FIRST),
+            |param| param.clear_flags(X509VerifyFlags::TRUSTED_FIRST),
         )
     );
 
     assert_eq!(
         Ok(()),
         verify(&leaf, &[&root1], &[&intermediate, &root1_cross], |param| {
-            param.clear_flags(X509Flags::TRUSTED_FIRST)
+            param.clear_flags(X509VerifyFlags::TRUSTED_FIRST);
         })
     );
 }
diff --git a/boring/src/x509/verify.rs b/boring/src/x509/verify.rs
index d89c67c8..3ca7ca9d 100644
--- a/boring/src/x509/verify.rs
+++ b/boring/src/x509/verify.rs
@@ -20,20 +20,14 @@ bitflags! {
         const NEVER_CHECK_SUBJECT = ffi::X509_CHECK_FLAG_NEVER_CHECK_SUBJECT as _;
         #[cfg(feature = "underscore-wildcards")]
         const UNDERSCORE_WILDCARDS = ffi::X509_CHECK_FLAG_UNDERSCORE_WILDCARDS as _;
-
-        #[deprecated(since = "0.10.6", note = "renamed to NO_WILDCARDS")]
-        const FLAG_NO_WILDCARDS = ffi::X509_CHECK_FLAG_NO_WILDCARDS as _;
     }
 }
 
-#[doc(hidden)]
-#[deprecated(note = "X509Flags renamed to X509VerifyFlags")]
-pub use X509VerifyFlags as X509Flags;
-
 bitflags! {
     /// Flags used to check an `X509` certificate.
     #[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord, Hash)]
     #[repr(transparent)]
+    #[doc(alias = "X509Flags")]
     pub struct X509VerifyFlags: c_ulong {
         const CB_ISSUER_CHECK = ffi::X509_V_FLAG_CB_ISSUER_CHECK as _;
         const USE_CHECK_TIME = ffi::X509_V_FLAG_USE_CHECK_TIME as _;
@@ -126,10 +120,9 @@ impl X509VerifyParamRef {
             let raw_host = if host.is_empty() { "\0" } else { host };
             cvt(ffi::X509_VERIFY_PARAM_set1_host(
                 self.as_ptr(),
-                raw_host.as_ptr() as *const _,
+                raw_host.as_ptr().cast(),
                 host.len(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -141,10 +134,9 @@ impl X509VerifyParamRef {
             let raw_email = if email.is_empty() { "\0" } else { email };
             cvt(ffi::X509_VERIFY_PARAM_set1_email(
                 self.as_ptr(),
-                raw_email.as_ptr() as *const _,
+                raw_email.as_ptr().cast(),
                 email.len(),
             ))
-            .map(|_| ())
         }
     }
 
@@ -165,10 +157,9 @@ impl X509VerifyParamRef {
             };
             cvt(ffi::X509_VERIFY_PARAM_set1_ip(
                 self.as_ptr(),
-                buf.as_ptr() as *const _,
+                buf.as_ptr().cast(),
                 len,
             ))
-            .map(|_| ())
         }
     }
 
@@ -189,6 +180,6 @@ impl X509VerifyParamRef {
     /// If a parameter is unset in `src`, the existing value in `self`` is preserved.
     #[corresponds(X509_VERIFY_PARAM_set1)]
     pub fn copy_from(&mut self, src: &Self) -> Result<(), ErrorStack> {
-        unsafe { cvt(ffi::X509_VERIFY_PARAM_set1(self.as_ptr(), src.as_ptr())).map(|_| ()) }
+        unsafe { cvt(ffi::X509_VERIFY_PARAM_set1(self.as_ptr(), src.as_ptr())) }
     }
 }
