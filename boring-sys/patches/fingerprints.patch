From 7c90db0c828b5dc85aed74576253ca8b219f68b0 Mon Sep 17 00:00:00 2001
From: Samuel Cobb <sjcobb2003@gmail.com>
Date: Fri, 6 Feb 2026 14:40:39 +0000
Subject: [PATCH] squash

---
 crypto/cipher/e_tls.cc  |  55 ++++++++
 include/openssl/aead.h  |   3 +
 include/openssl/nid.h   |   5 +
 include/openssl/ssl.h   |  83 +++++++++++-
 include/openssl/tls1.h  |  17 +++
 ssl/extensions.cc       | 130 ++++++++++++++++++-
 ssl/handshake_client.cc | 149 ++++++++++++++++-----
 ssl/internal.h          |  68 +++++++++-
 ssl/ssl_cipher.cc       | 280 +++++++++++++++++++++++++++++++++++++++-
 ssl/ssl_key_share.cc    |   2 +
 ssl/ssl_lib.cc          |  93 ++++++++++++-
 ssl/ssl_privkey.cc      |  10 ++
 12 files changed, 854 insertions(+), 41 deletions(-)

diff --git a/crypto/cipher/e_tls.cc b/crypto/cipher/e_tls.cc
index 39aaa2f57..60858e6d3 100644
--- a/crypto/cipher/e_tls.cc
+++ b/crypto/cipher/e_tls.cc
@@ -429,6 +429,22 @@ static int aead_aes_256_cbc_sha1_tls_implicit_iv_init(
                        EVP_sha1(), 1);
 }
 
+ 
+static int aead_aes_256_cbc_sha256_tls_init(EVP_AEAD_CTX *ctx,
+                                            const uint8_t *key, size_t key_len,
+                                            size_t tag_len,
+                                            enum evp_aead_direction_t dir) {
+  return aead_tls_init(ctx, key, key_len, tag_len, dir, EVP_aes_256_cbc(),
+                       EVP_sha256(), 0);
+}
+static int aead_aes_256_cbc_sha384_tls_init(EVP_AEAD_CTX *ctx,
+                                            const uint8_t *key, size_t key_len,
+                                            size_t tag_len,
+                                            enum evp_aead_direction_t dir) {
+  return aead_tls_init(ctx, key, key_len, tag_len, dir, EVP_aes_256_cbc(),
+                       EVP_sha384(), 0);
+}
+
 static int aead_des_ede3_cbc_sha1_tls_init(EVP_AEAD_CTX *ctx,
                                            const uint8_t *key, size_t key_len,
                                            size_t tag_len,
@@ -543,6 +559,38 @@ static const EVP_AEAD aead_aes_256_cbc_sha1_tls_implicit_iv = {
     aead_tls_tag_len,
 };
 
+static const EVP_AEAD aead_aes_256_cbc_sha256_tls = {
+    SHA256_DIGEST_LENGTH + 32,  // key len (SHA256 + AES256)
+    16,                         // nonce len (IV)
+    16 + SHA256_DIGEST_LENGTH,  // overhead (padding + SHA256)
+    SHA256_DIGEST_LENGTH,       // max tag length
+    0,                          // seal_scatter_supports_extra_in
+    NULL,  // init
+    aead_aes_256_cbc_sha256_tls_init,
+    aead_tls_cleanup,
+    aead_tls_open,
+    aead_tls_seal_scatter,
+    NULL,  // open_gather
+    NULL,  // get_iv
+    aead_tls_tag_len,
+};
+
+static const EVP_AEAD aead_aes_256_cbc_sha384_tls = {
+    SHA384_DIGEST_LENGTH + 32,  // key len (SHA384 + AES256)
+    16,                         // nonce len (IV)
+    16 + SHA384_DIGEST_LENGTH,  // overhead (padding + SHA384)
+    SHA384_DIGEST_LENGTH,       // max tag length
+    0,                          // seal_scatter_supports_extra_in
+    NULL,  // init
+    aead_aes_256_cbc_sha384_tls_init,
+    aead_tls_cleanup,
+    aead_tls_open,
+    aead_tls_seal_scatter,
+    NULL,  // open_gather
+    NULL,  // get_iv
+    aead_tls_tag_len,
+};
+
 static const EVP_AEAD aead_des_ede3_cbc_sha1_tls = {
     SHA_DIGEST_LENGTH + 24,  // key len (SHA1 + 3DES)
     8,                       // nonce len (IV)
@@ -597,6 +645,13 @@ const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv(void) {
   return &aead_aes_256_cbc_sha1_tls_implicit_iv;
 }
 
+const EVP_AEAD *EVP_aead_aes_256_cbc_sha256_tls(void) {
+  return &aead_aes_256_cbc_sha256_tls;
+}
+const EVP_AEAD *EVP_aead_aes_256_cbc_sha384_tls(void) {
+  return &aead_aes_256_cbc_sha384_tls;
+}
+
 const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls(void) {
   return &aead_des_ede3_cbc_sha1_tls;
 }
diff --git a/include/openssl/aead.h b/include/openssl/aead.h
index 97dd338a6..ddb8b5b64 100644
--- a/include/openssl/aead.h
+++ b/include/openssl/aead.h
@@ -413,6 +413,9 @@ OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_128_cbc_sha256_tls(void);
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls(void);
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv(void);
 
+OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha256_tls(void);
+OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha384_tls(void);
+
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls(void);
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv(void);
 
diff --git a/include/openssl/nid.h b/include/openssl/nid.h
index 7265f15f6..ebc1703df 100644
--- a/include/openssl/nid.h
+++ b/include/openssl/nid.h
@@ -5511,6 +5511,11 @@ extern "C" {
 #define SN_P256Kyber768Draft00 "P256Kyber768Draft00"
 #define NID_P256Kyber768Draft00 971
 
+#define SN_ffdhe2048 "ffdhe2048"
+#define NID_ffdhe2048 972
+
+#define SN_ffdhe3072 "ffdhe3072"
+#define NID_ffdhe3072 973
 
 #if defined(__cplusplus)
 } /* extern C */
diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index 0730e769a..12e1be5b8 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -616,6 +616,13 @@ OPENSSL_EXPORT int SSL_version(const SSL *ssl);
 #define SSL_OP_NO_DTLSv1 SSL_OP_NO_TLSv1
 #define SSL_OP_NO_DTLSv1_2 SSL_OP_NO_TLSv1_2
 
+ 
+// SSL_OP_NO_PSK_DHE_KE disables PSK-DHE-KE.
+#define SSL_OP_NO_PSK_DHE_KE 0x40000000L
+
+// SSL_OP_NO_RENEGOTIATION disables renegotiation. This is not recommended.
+#define SSL_OP_NO_RENEGOTIATION 0x80000000L
+
 // SSL_CTX_set_options enables all options set in |options| (which should be one
 // or more of the |SSL_OP_*| values, ORed together) in |ctx|. It returns a
 // bitmask representing the resulting enabled options.
@@ -1481,6 +1488,20 @@ DEFINE_CONST_STACK_OF(SSL_CIPHER)
 #define SSL_CIPHER_PSK_WITH_AES_256_CBC_SHA 0x008d
 #define SSL_CIPHER_RSA_WITH_3DES_EDE_CBC_SHA 0x000a
 
+#define SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA 0x0033
+#define SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA 0x0039
+#define SSL_CIPHER_RSA_WITH_AES_128_SHA256 0x003C
+#define SSL_CIPHER_RSA_WITH_AES_256_SHA256 0x003D
+#define SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA256 0x0067
+#define SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA256 0x006B
+#define SSL_CIPHER_DHE_RSA_WITH_AES_128_GCM_SHA256 0x009E
+#define SSL_CIPHER_DHE_RSA_WITH_AES_256_GCM_SHA384 0x009F
+#define SSL_CIPHER_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA 0xC008
+#define SSL_CIPHER_ECDHE_RSA_WITH_DES_192_CBC3_SHA 0xC012
+#define SSL_CIPHER_ECDHE_ECDSA_WITH_AES_128_SHA256 0xC023
+#define SSL_CIPHER_ECDHE_ECDSA_WITH_AES_256_SHA384 0xC024
+#define SSL_CIPHER_ECDHE_RSA_WITH_AES_256_SHA384 0xC028
+
 // The following constants are not cipher suites, but are used in the protocol
 // as signalling values.
 #define SSL_CIPHER_EMPTY_RENEGOTIATION_INFO_SCSV 0x00ff
@@ -5236,6 +5257,60 @@ OPENSSL_EXPORT void SSL_CTX_set_permute_extensions(SSL_CTX *ctx, int enabled);
 // permute extensions. For now, this is only implemented for the ClientHello.
 OPENSSL_EXPORT void SSL_set_permute_extensions(SSL *ssl, int enabled);
 
+// SSL_CTX_set_extension_order configures whether sockets on |ctx|
+// should make use of the provided extensions to define the order,
+// which is similar to SSL_CTX_set_permute_extensions but in a defined
+// order instead of a random one.
+OPENSSL_EXPORT int SSL_CTX_set_extension_order(SSL_CTX *ctx, const uint16_t *ids, int num);
+
+// SSL_set_record_size_limit configures whether sockets on |ssl| should
+// send record size limit extension.
+OPENSSL_EXPORT void SSL_set_record_size_limit(SSL *ssl, uint16_t limit);
+
+// SSL_CTX_set_record_size_limit configures whether sockets on |ctx| should
+// send record size limit extension.
+OPENSSL_EXPORT void SSL_CTX_set_record_size_limit(SSL_CTX *ctx, uint16_t limit);
+
+// SSL_set_key_shares_limit configures whether sockets on |ssl| should
+// send key shares limit.
+OPENSSL_EXPORT void SSL_set_key_shares_limit(SSL *ssl, uint8_t limit);
+
+// SSL_CTX_set_key_shares_limit configures whether sockets on |ctx| should
+// send key shares limit.
+OPENSSL_EXPORT void SSL_CTX_set_key_shares_limit(SSL_CTX *ctx, uint8_t limit);
+
+// SSL_CTX_set_aes_hw_override sets |override_value| to
+// override checking for aes hardware support. If |override_value|
+// is set to true, the library will behave as if aes hardware support is
+// present. If it is set to false, the library will behave as if aes hardware
+// support is not present.
+OPENSSL_EXPORT void SSL_CTX_set_aes_hw_override(SSL_CTX *ctx, int override_value);
+
+// SSL_set_aes_hw_override acts the same as
+// |SSL_CTX_set_aes_override| but only configures a single |SSL*|.
+OPENSSL_EXPORT void SSL_set_aes_hw_override(SSL *ssl, int override_value);
+
+// SSL_CTX_set_preserve_tls13_cipher_list configures whether sockets on |ctx| should
+// preserve the TLS 1.3 cipher list order, retaining the original cipher suite
+// preferences. When enabled, it may prefer ChaCha20 over AES based on the
+// configured list. This is only relevant for TLS 1.3 and later, where ChaCha20
+// is not the default cipher suite.
+//
+// Note: This function must be called before |SSL_CTX_set_cipher_list| to take
+// effect.
+OPENSSL_EXPORT void SSL_CTX_set_preserve_tls13_cipher_list(SSL_CTX *ctx,
+                                                  int preserve_tls13_cipher_list);
+
+// SSL_set_preserve_tls13_cipher_list configures whether sockets on |ctx| should
+// preserve the TLS 1.3 cipher list order, retaining the original cipher suite
+// preferences. When enabled, it may prefer ChaCha20 over AES based on the
+// configured list. This is only relevant for TLS 1.3 and later, where ChaCha20
+// is not the default cipher suite.
+//
+// Note: This function must be called before |SSL_set_cipher_list| to take
+// effect.
+OPENSSL_EXPORT void SSL_set_preserve_tls13_cipher_list(SSL *ssl, int preserve_tls13_cipher_list);
+
 // SSL_max_seal_overhead returns the maximum overhead, in bytes, of sealing a
 // record with |ssl|.
 OPENSSL_EXPORT size_t SSL_max_seal_overhead(const SSL *ssl);
@@ -5563,6 +5638,10 @@ OPENSSL_EXPORT int SSL_CTX_set1_sigalgs_list(SSL_CTX *ctx, const char *str);
 // more convenient to codesearch for specific algorithm values.
 OPENSSL_EXPORT int SSL_set1_sigalgs_list(SSL *ssl, const char *str);
 
+// SSL_CTX_set_delegated_credentials sets the set of signature algorithms supported
+// by the client.
+OPENSSL_EXPORT int SSL_CTX_set_delegated_credentials(SSL_CTX *ctx, const char *str);
+
 #define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)(arg)))
 #define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))
 #define SSL_SESSION_set_app_data(s, a) \
@@ -5615,7 +5694,6 @@ DEFINE_STACK_OF(SSL_COMP)
 #define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG 0
 #define SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG 0
 #define SSL_OP_NO_COMPRESSION 0
-#define SSL_OP_NO_RENEGOTIATION 0  // ssl_renegotiate_never is the default
 #define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION 0
 #define SSL_OP_NO_SSLv2 0
 #define SSL_OP_NO_SSLv3 0
@@ -5942,6 +6020,9 @@ OPENSSL_EXPORT int SSL_CTX_set_tlsext_status_arg(SSL_CTX *ctx, void *arg);
 #define SSL_CURVE_X25519 SSL_GROUP_X25519
 #define SSL_CURVE_X25519_KYBER768_DRAFT00 SSL_GROUP_X25519_KYBER768_DRAFT00
 
+#define SSL_CURVE_DHE2048 256
+#define SSL_CURVE_DHE3072 257
+
 // SSL_get_curve_id calls |SSL_get_group_id|.
 OPENSSL_EXPORT uint16_t SSL_get_curve_id(const SSL *ssl);
 
diff --git a/include/openssl/tls1.h b/include/openssl/tls1.h
index ea55e2a07..d0d5a3933 100644
--- a/include/openssl/tls1.h
+++ b/include/openssl/tls1.h
@@ -48,6 +48,8 @@ extern "C" {
 #define TLS1_AD_NO_APPLICATION_PROTOCOL 120
 #define TLS1_AD_ECH_REQUIRED 121  // draft-ietf-tls-esni-13
 
+#define TLSEXT_TYPE_record_size_limit 28
+
 // ExtensionType values from RFC 6066
 #define TLSEXT_TYPE_server_name 0
 #define TLSEXT_TYPE_status_request 5
@@ -166,6 +168,7 @@ extern "C" {
 // From https://www.rfc-editor.org/rfc/rfc8879.html#section-3
 #define TLSEXT_cert_compression_zlib 1
 #define TLSEXT_cert_compression_brotli 2
+#define TLSEXT_cert_compression_zstd 3
 
 #define TLSEXT_MAXLEN_host_name 255
 
@@ -237,6 +240,20 @@ extern "C" {
 #define TLS1_3_RFC_AES_256_GCM_SHA384 "TLS_AES_256_GCM_SHA384"
 #define TLS1_3_RFC_CHACHA20_POLY1305_SHA256 "TLS_CHACHA20_POLY1305_SHA256"
 
+#define TLS1_TXT_DHE_RSA_WITH_AES_128_SHA "DHE-RSA-AES128-SHA"
+#define TLS1_TXT_DHE_RSA_WITH_AES_256_SHA "DHE-RSA-AES256-SHA"
+#define TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256 "DHE-RSA-AES128-SHA256"
+#define TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256 "DHE-RSA-AES256-SHA256"
+#define TLS1_TXT_RSA_WITH_AES_128_SHA256 "AES128-SHA256"
+#define TLS1_TXT_RSA_WITH_AES_256_SHA256 "AES256-SHA256"
+#define TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256 "DHE-RSA-AES128-GCM-SHA256"
+#define TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384 "DHE-RSA-AES256-GCM-SHA384"
+#define TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA "ECDHE-ECDSA-DES-CBC3-SHA"
+#define TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA "ECDHE-RSA-DES-CBC3-SHA"
+#define TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256 "ECDHE-ECDSA-AES128-SHA256"
+#define TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384 "ECDHE-ECDSA-AES256-SHA384"
+#define TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384 "ECDHE-RSA-AES256-SHA384"
+
 #define TLS_CT_RSA_SIGN 1
 #define TLS_CT_DSS_SIGN 2
 #define TLS_CT_RSA_FIXED_DH 3
diff --git a/ssl/extensions.cc b/ssl/extensions.cc
index e0514fed3..422ced8ee 100644
--- a/ssl/extensions.cc
+++ b/ssl/extensions.cc
@@ -2039,7 +2039,7 @@ bool ssl_ext_pre_shared_key_add_serverhello(SSL_HANDSHAKE *hs, CBB *out) {
 static bool ext_psk_key_exchange_modes_add_clienthello(
     const SSL_HANDSHAKE *hs, CBB *out, CBB *out_compressible,
     ssl_client_hello_type_t type) {
-  if (hs->max_version < TLS1_3_VERSION) {
+  if (hs->max_version < TLS1_3_VERSION || (SSL_get_options(hs->ssl) & SSL_OP_NO_PSK_DHE_KE)) {
     return true;
   }
   // We do not support resumption with PAKEs, so do not offer any PSK key
@@ -2971,6 +2971,26 @@ static bool ext_quic_transport_params_add_serverhello_legacy(SSL_HANDSHAKE *hs,
 static bool ext_delegated_credential_add_clienthello(
     const SSL_HANDSHAKE *hs, CBB *out, CBB *out_compressible,
     ssl_client_hello_type_t type) {
+    if (hs->config->delegated_credentials.empty()) {
+        return true;
+    }
+
+    CBB contents, data;
+    const Array<uint16_t>& signature_hash_algorithms = hs->config->delegated_credentials;
+    if (!CBB_add_u16(out, TLSEXT_TYPE_delegated_credential) ||
+            !CBB_add_u16_length_prefixed(out, &contents) ||
+            !CBB_add_u16_length_prefixed(&contents, &data)) {
+        return false;
+    }
+    
+    for (const uint16_t alg : signature_hash_algorithms) {
+        if (!CBB_add_u16(&data, alg)) {
+            return false;
+        }
+    }
+    if (!CBB_flush(out)) {
+        return false;
+    }
   return true;
 }
 
@@ -3527,6 +3547,39 @@ bool ssl_negotiate_alps(SSL_HANDSHAKE *hs, uint8_t *out_alert,
   return true;
 }
 
+static bool record_size_limit_add_clienthello(const SSL_HANDSHAKE* hs, CBB* out,
+    CBB* out_compressible,
+    ssl_client_hello_type_t type) {
+    if (hs->config->record_size_limit == 0) {
+        return true;
+    }
+
+    CBB data;
+    const uint16_t data_ = hs->config->record_size_limit;
+    if (!CBB_add_u16(out, TLSEXT_TYPE_record_size_limit) ||
+        !CBB_add_u16_length_prefixed(out, &data) || !CBB_add_u16(&data, data_) ||
+        !CBB_flush(out)) {
+        return false;
+    }
+    return true;
+  }
+
+static bool record_size_limit_parse_serverhello(SSL_HANDSHAKE* hs,
+    uint8_t* out_alert,
+    CBS* contents) {
+    return true;
+}
+
+static bool record_size_limit_parse_clienthello(SSL_HANDSHAKE* hs,
+    uint8_t* out_alert,
+    CBS* contents) {
+    return true;
+}
+
+static bool record_size_limit_add_serverhello(SSL_HANDSHAKE* hs, CBB* out) {
+    return true;
+}
+
 // kExtensions contains all the supported extensions.
 static const struct tls_extension kExtensions[] = {
     {
@@ -3731,6 +3784,13 @@ static const struct tls_extension kExtensions[] = {
         ext_trust_anchors_parse_clienthello,
         ext_trust_anchors_add_serverhello,
     },
+    {
+        TLSEXT_TYPE_record_size_limit,
+        record_size_limit_add_clienthello,
+        record_size_limit_parse_serverhello,
+        record_size_limit_parse_clienthello,
+        record_size_limit_add_serverhello,
+    },
 };
 
 #define kNumExtensions (sizeof(kExtensions) / sizeof(struct tls_extension))
@@ -3742,6 +3802,74 @@ static_assert(kNumExtensions <=
                   sizeof(((SSL_HANDSHAKE *)nullptr)->extensions.received) * 8,
               "too many extensions for received bitset");
 
+bool ssl_setup_extension_order(SSL_HANDSHAKE *hs) {
+    SSL *const ssl = hs->ssl;
+    if (ssl->ctx->extension_order.empty()) {
+        return ssl_setup_extension_permutation(hs);
+    }
+
+    static_assert(kNumExtensions <= UINT8_MAX,
+                  "extensions_permutation type is too small");
+    Array<uint8_t> permutation;
+    if (!permutation.Init(kNumExtensions)) {
+      return false;
+    }
+
+    bool seen[kNumExtensions] = {0};
+    int permIndex = 0;
+
+    for (uint16_t id : ssl->ctx->extension_order) {
+        size_t j;
+        for (j = 0; j < kNumExtensions; j++) {
+            if (kExtensions[j].value == id) {
+                break;
+            }
+        }
+        if (j == kNumExtensions || seen[j]) {
+            continue;  // Skip unknown or duplicate entries
+        }
+        seen[j] = true;
+        permutation[permIndex++] = j;
+    }
+
+    size_t rem = kNumExtensions - permIndex;
+    if (rem == 0) {
+        hs->extension_permutation = std::move(permutation);
+        return true;
+    }
+
+    size_t offset = permIndex;
+    for (size_t i = 0; i < kNumExtensions; i++) {
+        if (seen[i]) {
+            continue; // skip duplicate entries
+        }
+        seen[i] = true;
+        permutation[permIndex++] = i;
+    }
+
+    if (rem > 1) {
+        size_t seeds_num = rem - 1;
+        uint32_t *seeds = static_cast<uint32_t *>(OPENSSL_malloc(seeds_num * sizeof(uint32_t)));
+        if (!seeds) {
+            permutation.Reset();
+            return false;
+        }
+        if (!RAND_bytes(reinterpret_cast<uint8_t *>(seeds), seeds_num * sizeof(uint32_t))) {
+            permutation.Reset();
+            OPENSSL_free(seeds);
+            return false;
+        }
+        for (size_t i = kNumExtensions - 1; i > offset; i--) {
+            size_t swap_idx = offset + (seeds[i - offset] % (i - offset));
+            std::swap(permutation[i], permutation[swap_idx]);
+        }
+        OPENSSL_free(seeds);
+    }
+
+    hs->extension_permutation = std::move(permutation);
+    return true;
+}
+
 bool ssl_setup_extension_permutation(SSL_HANDSHAKE *hs) {
   if (!hs->config->permute_extensions) {
     return true;
diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index c96dedc4d..1c42bdaf4 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -26,6 +26,7 @@
 #include <openssl/aead.h>
 #include <openssl/bn.h>
 #include <openssl/bytestring.h>
+#include <openssl/dh.h>
 #include <openssl/ec_key.h>
 #include <openssl/ecdsa.h>
 #include <openssl/err.h>
@@ -39,6 +40,7 @@
 #include "../crypto/internal.h"
 #include "internal.h"
 
+#include "../crypto/fipsmodule/dh/internal.h"
 
 BSSL_NAMESPACE_BEGIN
 
@@ -110,35 +112,49 @@ static bool ssl_write_client_cipher_list(const SSL_HANDSHAKE *hs, CBB *out,
   // Add TLS 1.3 ciphers. Order ChaCha20-Poly1305 relative to AES-GCM based on
   // hardware support.
   if (hs->max_version >= TLS1_3_VERSION) {
-    static const uint16_t kCiphersNoAESHardware[] = {
-        SSL_CIPHER_CHACHA20_POLY1305_SHA256,
-        SSL_CIPHER_AES_128_GCM_SHA256,
-        SSL_CIPHER_AES_256_GCM_SHA384,
-    };
-    static const uint16_t kCiphersAESHardware[] = {
-        SSL_CIPHER_AES_128_GCM_SHA256,
-        SSL_CIPHER_AES_256_GCM_SHA384,
-        SSL_CIPHER_CHACHA20_POLY1305_SHA256,
-    };
-    static const uint16_t kCiphersCNSA[] = {
-        SSL_CIPHER_AES_256_GCM_SHA384,
-        SSL_CIPHER_AES_128_GCM_SHA256,
-        SSL_CIPHER_CHACHA20_POLY1305_SHA256,
-    };
-
-    const bool has_aes_hw = ssl->config->aes_hw_override
-                                ? ssl->config->aes_hw_override_value
-                                : EVP_has_aes_hardware();
-    const bssl::Span<const uint16_t> ciphers =
-        ssl->config->compliance_policy == ssl_compliance_policy_cnsa_202407
-            ? bssl::Span<const uint16_t>(kCiphersCNSA)
-            : (has_aes_hw ? bssl::Span<const uint16_t>(kCiphersAESHardware)
-                          : bssl::Span<const uint16_t>(kCiphersNoAESHardware));
-
-    for (auto cipher : ciphers) {
-      if (!ssl_add_tls13_cipher(&child, cipher,
-                                ssl->config->compliance_policy)) {
-        return false;
+    if (ssl->config->preserve_tls13_cipher_list &&
+        ssl->ctx->tls13_cipher_list != NULL &&
+        sk_SSL_CIPHER_num(ssl->ctx->tls13_cipher_list->ciphers.get()) >= 1) {
+      // Use the preserved cipher list order
+      for (size_t i = 0; i < sk_SSL_CIPHER_num(ssl->ctx->tls13_cipher_list->ciphers.get()); i++) {
+        const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(ssl->ctx->tls13_cipher_list->ciphers.get(), i);
+        uint16_t cipher_id = SSL_CIPHER_get_protocol_id(cipher);
+        if (!ssl_add_tls13_cipher(&child, cipher_id, ssl->config->compliance_policy)) {
+          return false;
+        }
+      }
+    } else {
+      // Use the default cipher ordering based on hardware support and compliance policy
+      static const uint16_t kCiphersNoAESHardware[] = {
+          SSL_CIPHER_CHACHA20_POLY1305_SHA256,
+          SSL_CIPHER_AES_128_GCM_SHA256,
+          SSL_CIPHER_AES_256_GCM_SHA384,
+      };
+      static const uint16_t kCiphersAESHardware[] = {
+          SSL_CIPHER_AES_128_GCM_SHA256,
+          SSL_CIPHER_AES_256_GCM_SHA384,
+          SSL_CIPHER_CHACHA20_POLY1305_SHA256,
+      };
+      static const uint16_t kCiphersCNSA[] = {
+          SSL_CIPHER_AES_256_GCM_SHA384,
+          SSL_CIPHER_AES_128_GCM_SHA256,
+          SSL_CIPHER_CHACHA20_POLY1305_SHA256,
+      };
+  
+      const bool has_aes_hw = ssl->config->aes_hw_override
+                                  ? ssl->config->aes_hw_override_value
+                                  : EVP_has_aes_hardware();
+      const bssl::Span<const uint16_t> ciphers =
+          ssl->config->compliance_policy == ssl_compliance_policy_cnsa_202407
+              ? bssl::Span<const uint16_t>(kCiphersCNSA)
+              : (has_aes_hw ? bssl::Span<const uint16_t>(kCiphersAESHardware)
+                            : bssl::Span<const uint16_t>(kCiphersNoAESHardware));
+  
+      for (auto cipher : ciphers) {
+        if (!ssl_add_tls13_cipher(&child, cipher,
+                                  ssl->config->compliance_policy)) {
+          return false;
+        }
       }
     }
   }
@@ -432,7 +448,7 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
   }
 
   if (!ssl_setup_key_shares(hs, /*override_group_id=*/0) ||
-      !ssl_setup_extension_permutation(hs) ||
+      !ssl_setup_extension_order(hs) ||
       !ssl_encrypt_client_hello(hs, Span(ech_enc, ech_enc_len)) ||
       !ssl_add_client_hello(hs)) {
     return ssl_hs_error;
@@ -1025,7 +1041,26 @@ static enum ssl_hs_wait_t do_read_server_key_exchange(SSL_HANDSHAKE *hs) {
     hs->peer_psk_identity_hint.reset(raw);
   }
 
-  if (alg_k & SSL_kECDHE) {
+  if (alg_k & SSL_kDHE) {
+    CBS dh_p, dh_g, dh_Ys;
+    if (!CBS_get_u16_length_prefixed(&server_key_exchange, &dh_p) ||
+        CBS_len(&dh_p) == 0 ||
+        !CBS_get_u16_length_prefixed(&server_key_exchange, &dh_g) ||
+        CBS_len(&dh_g) == 0 ||
+        !CBS_get_u16_length_prefixed(&server_key_exchange, &dh_Ys) ||
+        CBS_len(&dh_Ys) == 0) {
+      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
+      return ssl_hs_error;
+    }
+    if (!hs->dh_p.CopyFrom(dh_p) || !hs->dh_g.CopyFrom(dh_g)) {
+      return ssl_hs_error;
+    }
+    /* Save the peer public key for later. */
+    if (!hs->peer_key.CopyFrom(dh_Ys)) {
+      return ssl_hs_error;
+    }
+  } else if (alg_k & SSL_kECDHE) {
     // Parse the server parameters.
     uint8_t group_type;
     uint16_t group_id;
@@ -1439,6 +1474,58 @@ static enum ssl_hs_wait_t do_send_client_key_exchange(SSL_HANDSHAKE *hs) {
         !CBB_flush(&body)) {
       return ssl_hs_error;
     }
+  } else if (alg_k & SSL_kDHE) {
+    DH *dh = DH_new();
+    if (dh == nullptr) {
+      return ssl_hs_error;
+    }
+    dh->p = BN_bin2bn(hs->dh_p.data(), hs->dh_p.size(), nullptr);
+    dh->g = BN_bin2bn(hs->dh_g.data(), hs->dh_g.size(), nullptr);
+    if (dh->p == nullptr || dh->g == nullptr) {
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+    unsigned bits = DH_num_bits(dh);
+    if (bits < 1024) {
+      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_DH_P_LENGTH);
+      DH_free(dh);
+      return ssl_hs_error;
+    } else if (bits > 4096) {
+      /* Overly large DHE groups are prohibitively expensive, so enforce a limit
+       * to prevent a server from causing us to perform too expensive of a
+       * computation. */
+      OPENSSL_PUT_ERROR(SSL, SSL_R_DH_P_TOO_LONG);
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+    
+    CBB child;
+    if (!CBB_add_u16_length_prefixed(&body, &child)) {
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+    if (!DH_generate_key(dh) || 
+        !BN_bn2cbb_padded(&child, BN_num_bytes(dh->p), dh->pub_key)) {
+      DH_free(dh);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
+      return ssl_hs_error;
+    }
+    int secret_len = 0;
+    BIGNUM *peer_point = BN_bin2bn(hs->peer_key.data(), hs->peer_key.size(), nullptr);
+    if (peer_point == nullptr || 
+        !pms.InitForOverwrite(DH_size(dh)) || 
+        (secret_len = DH_compute_key(pms.data(), peer_point, dh)) <= 0) {
+      BN_free(peer_point);
+      DH_free(dh);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
+      return ssl_hs_error;
+    }
+    pms.Shrink(secret_len);
+    BN_free(peer_point);
+    DH_free(dh);
+    hs->dh_p.Reset();
+    hs->dh_g.Reset();
+    hs->peer_key.Reset();
   } else if (alg_k & SSL_kECDHE) {
     CBB child;
     if (!CBB_add_u8_length_prefixed(&body, &child)) {
diff --git a/ssl/internal.h b/ssl/internal.h
index 1f5ce51e6..26fc674fe 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -257,10 +257,11 @@ BSSL_NAMESPACE_BEGIN
 
 // Bits for |algorithm_mkey| (key exchange algorithm).
 #define SSL_kRSA 0x00000001u
-#define SSL_kECDHE 0x00000002u
+#define SSL_kDHE 0x00000002u
+#define SSL_kECDHE 0x00000004u
 // SSL_kPSK is only set for plain PSK, not ECDHE_PSK.
-#define SSL_kPSK 0x00000004u
-#define SSL_kGENERIC 0x00000008u
+#define SSL_kPSK 0x00000008u
+#define SSL_kGENERIC 0x00000010u
 
 // Bits for |algorithm_auth| (server authentication).
 #define SSL_aRSA_SIGN 0x00000001u
@@ -285,8 +286,14 @@ BSSL_NAMESPACE_BEGIN
 // Bits for |algorithm_mac| (symmetric authentication).
 #define SSL_SHA1 0x00000001u
 #define SSL_SHA256 0x00000002u
+
+// SSL_SHA384 was removed in
+// https://boringssl-review.googlesource.com/c/boringssl/+/27944/
+// but restored to impersonate browsers with older ciphers.
+#define SSL_SHA384 0x00000004u
+
 // SSL_AEAD is set for all AEADs.
-#define SSL_AEAD 0x00000004u
+#define SSL_AEAD 0x00000008u
 
 // Bits for |algorithm_prf| (handshake digest).
 #define SSL_HANDSHAKE_MAC_DEFAULT 0x1
@@ -370,6 +377,12 @@ bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
                             const bool has_aes_hw, const char *rule_str,
                             bool strict);
 
+// ssl_create_tls13_cipher_list is like |ssl_create_cipher_list| but only
+// supports TLS 1.3 cipher suites.
+bool ssl_create_preserve_tls13_cipher_list(
+    UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
+    const char *rule_str, bool strict);
+
 // ssl_cipher_auth_mask_for_key returns the mask of cipher |algorithm_auth|
 // values suitable for use with |key| in TLS 1.2 and below. |sign_ok| indicates
 // whether |key| may be used for signing.
@@ -955,7 +968,7 @@ struct NamedGroup {
 Span<const NamedGroup> NamedGroups();
 
 // kNumNamedGroups is the number of supported groups.
-constexpr size_t kNumNamedGroups = 8u;
+constexpr size_t kNumNamedGroups = 10u;
 
 // DefaultSupportedGroupIds returns the list of IDs for the default groups that
 // are supported when the caller hasn't explicitly configured supported groups.
@@ -1830,6 +1843,10 @@ struct SSL_HANDSHAKE {
   // delegated credentials.
   Array<uint16_t> peer_delegated_credential_sigalgs;
 
+ 
+  Array<uint8_t> dh_p;
+  Array<uint8_t> dh_g;
+
   // peer_key is the peer's ECDH key for a TLS 1.2 client.
   Array<uint8_t> peer_key;
 
@@ -2124,6 +2141,10 @@ bool tls13_process_new_session_ticket(SSL *ssl, const SSLMessage &msg);
 bssl::UniquePtr<SSL_SESSION> tls13_create_session_with_ticket(SSL *ssl,
                                                               CBS *body);
 
+// defined by the provided extension order, or falls back
+// to ssl_setup_extension_permutation otherwise.
+bool ssl_setup_extension_order(SSL_HANDSHAKE *hs);
+
 // ssl_setup_extension_permutation computes a ClientHello extension permutation
 // for |hs|, if applicable. It returns true on success and false on error.
 bool ssl_setup_extension_permutation(SSL_HANDSHAKE *hs);
@@ -3327,6 +3348,10 @@ struct SSL_CONFIG {
   // accepted from the peer in decreasing order of preference.
   Array<uint16_t> verify_sigalgs;
 
+  // delegated_credentials, if not empty, is the set of signature algorithms
+  // supported by the client.
+  Array<uint16_t> delegated_credentials;
+
   // srtp_profiles is the list of configured SRTP protection profiles for
   // DTLS-SRTP.
   UniquePtr<STACK_OF(SRTP_PROTECTION_PROFILE)> srtp_profiles;
@@ -3405,6 +3430,17 @@ struct SSL_CONFIG {
   // alps_use_new_codepoint if set indicates we use new ALPS extension codepoint
   // to negotiate and convey application settings.
   bool alps_use_new_codepoint : 1;
+
+  // record_size_limit is whether to send record size limit extension.
+  uint16_t record_size_limit = 0;
+
+  // key_shares_limit is the maximum number of key shares to send.
+  uint8_t key_shares_limit = 0;
+
+  // preserve_tls13_cipher_list indicates that the TLS 1.3 cipher list order should
+  // be preserved, potentially preferring ChaCha20-Poly1305 over AES-GCM ciphers.
+  // It is only effective on the client side.
+  bool preserve_tls13_cipher_list : 1;
 };
 
 // From RFC 8446, used in determining PSK modes.
@@ -3993,6 +4029,10 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
   // accepted from the peer in decreasing order of preference.
   bssl::Array<uint16_t> verify_sigalgs;
 
+  // delegated_credentials, if not empty, is the set of signature algorithms
+  // supported by the client.
+  bssl::Array<uint16_t> delegated_credentials;
+
   // retain_only_sha256_of_client_certs is true if we should compute the SHA256
   // hash of the peer's certificate and then discard it to save memory and
   // session space. Only effective on the server side.
@@ -4016,6 +4056,10 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
 
   // grease_enabled is whether GREASE (RFC 8701) is enabled.
   bool grease_enabled : 1;
+  
+  // rama_ssl_extension_order, if not empty, will use this actions
+  // as the order to be used to write the ssl extensions.
+  bssl::Array<uint16_t> extension_order;
 
   // permute_extensions is whether to permute extensions when sending messages.
   bool permute_extensions : 1;
@@ -4054,6 +4098,20 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
   // signal its sessions may be resumed across names in the server certificate.
   bool resumption_across_names_enabled : 1;
 
+  // record_size_limit is whether to send record size limit extension.
+  uint16_t record_size_limit = 0;
+
+  // key_shares limit is the maximum number of key shares to send.
+  uint8_t key_shares_limit = 0;
+
+  // preserve_tls13_cipher_list indicates that the TLS 1.3 cipher list order should
+  // be preserved, potentially preferring ChaCha20-Poly1305 over AES-GCM ciphers.
+  // It is only effective on the client side.
+  bool preserve_tls13_cipher_list : 1;
+
+  // tls13_cipher_list, if non-null, is the list of ciphers to use in TLS 1.3
+  bssl::UniquePtr<bssl::SSLCipherPreferenceList> tls13_cipher_list;
+
  private:
   friend RefCounted;
   ~ssl_ctx_st();
diff --git a/ssl/ssl_cipher.cc b/ssl/ssl_cipher.cc
index 010e2ae43..9c5b85c8d 100644
--- a/ssl/ssl_cipher.cc
+++ b/ssl/ssl_cipher.cc
@@ -63,6 +63,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // Cipher 33
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_SHA,
+        "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
+        SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher 35
     {
         TLS1_TXT_RSA_WITH_AES_256_SHA,
@@ -75,6 +87,72 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // Cipher 39
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_SHA,
+        "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
+        SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
+    // Ciphers 3C, 3D were removed in
+    // https://boringssl-review.googlesource.com/c/boringssl/+/27944/
+    // but restored here to impersonate browsers with older ciphers. They are
+    // not expected to actually work; but just to be included in the TLS
+    // Client Hello.
+
+    // Cipher 3C
+    {
+        TLS1_TXT_RSA_WITH_AES_128_SHA256,
+        "TLS_RSA_WITH_AES_128_CBC_SHA256",
+        SSL_CIPHER_RSA_WITH_AES_128_SHA256,
+        SSL_kRSA,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 3D
+    {
+        TLS1_TXT_RSA_WITH_AES_256_SHA256,
+        "TLS_RSA_WITH_AES_256_CBC_SHA256",
+        SSL_CIPHER_RSA_WITH_AES_256_SHA256,
+        SSL_kRSA,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 67
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256,
+        "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
+        SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 6B
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256,
+        "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
+        SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
     // PSK cipher suites.
 
     // Cipher 8C
@@ -127,6 +205,30 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA384,
     },
 
+    // Cipher 9E
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256,
+        "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
+        SSL_CIPHER_DHE_RSA_WITH_AES_128_GCM_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128GCM,
+        SSL_AEAD,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 9F
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384,
+        "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
+        SSL_CIPHER_DHE_RSA_WITH_AES_256_GCM_SHA384,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256GCM,
+        SSL_AEAD,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // TLS 1.3 suites.
 
     // Cipher 1301
@@ -165,6 +267,23 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA256,
     },
 
+    //  Cipher C008 was missing from BoringSSL,
+    // probably because it is weak. Add it back from OpenSSL (ssl/s3_lib.c)
+    // where it is called ECDHE-ECDSA-DES-CBC3-SHA.
+    // It's not supposed to really work but just appear in the TLS client hello.
+ 
+    // Cipher C008
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
+        "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
+        SSL_CIPHER_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_3DES,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher C009
     {
         TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
@@ -189,6 +308,21 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    //  Cipher C012 was missing from BoringSSL,
+    // probably because it is weak. Add it back from OpenSSL (ssl/s3_lib.c)
+    // where it is called ECDHE-RSA-DES-CBC3-SHA
+    // It's not supposed to really work but just appear in the TLS client hello.
+    {
+        TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
+        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
+        SSL_CIPHER_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
+        SSL_kECDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_3DES,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher C013
     {
         TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA,
@@ -213,6 +347,39 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    //  Ciphers C023, C024, C028 were removed in
+    // https://boringssl-review.googlesource.com/c/boringssl/+/27944/
+    // but restored here to impersonate browsers with older ciphers. They are
+    // not expected to actually work; but just to be included in the TLS
+    // Client Hello.
+
+    // HMAC based TLS v1.2 ciphersuites from RFC5289
+
+    // Cipher C023
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256,
+        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
+        SSL_CIPHER_ECDHE_ECDSA_WITH_AES_128_SHA256,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+
+    // Cipher C024
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384,
+        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
+        SSL_CIPHER_ECDHE_ECDSA_WITH_AES_256_SHA384,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_AES256,
+        SSL_SHA384,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // Cipher C027
     {
         TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
@@ -225,6 +392,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA256,
     },
 
+    // Cipher C028
+    {
+        TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384,
+        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
+        SSL_CIPHER_ECDHE_RSA_WITH_AES_256_SHA384,
+        SSL_kECDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA384,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // GCM based TLS v1.2 ciphersuites from RFC 5289
 
     // Cipher C02B
@@ -431,6 +610,11 @@ static const CIPHER_ALIAS kCipherAliases[] = {
     {"SHA1", ~0u, ~0u, ~0u, SSL_SHA1, 0},
     {"SHA", ~0u, ~0u, ~0u, SSL_SHA1, 0},
 
+    // Removed in https://boringssl-review.googlesource.com/c/boringssl/+/27944/
+    // but restored to impersonate browsers with older ciphers.
+    {"SHA256", ~0u, ~0u, ~0u, SSL_SHA256, 0},
+    {"SHA384", ~0u, ~0u, ~0u, SSL_SHA384, 0},
+
     // Legacy protocol minimum version aliases. "TLSv1" is intentionally the
     // same as "SSLv3".
     {"SSLv3", ~0u, ~0u, ~0u, ~0u, SSL3_VERSION},
@@ -514,11 +698,20 @@ bool ssl_cipher_get_evp_aead(const EVP_AEAD **out_aead,
   } else if (cipher->algorithm_mac == SSL_SHA256) {
     if (cipher->algorithm_enc == SSL_AES128) {
       *out_aead = EVP_aead_aes_128_cbc_sha256_tls();
-    } else {
+    } else if (cipher->algorithm_enc == SSL_AES256) {
+      *out_aead = EVP_aead_aes_256_cbc_sha256_tls();
+    }
+      else {
       return false;
     }
 
     *out_mac_secret_len = SHA256_DIGEST_LENGTH;
+  } else if (cipher->algorithm_mac == SSL_SHA384) {
+    if (cipher->algorithm_enc != SSL_AES256) {
+      return false;
+    }
+    *out_aead = EVP_aead_aes_256_cbc_sha384_tls();
+    *out_mac_secret_len = SHA384_DIGEST_LENGTH;
   } else {
     return false;
   }
@@ -998,6 +1191,72 @@ static bool ssl_cipher_process_rulestr(const char *rule_str,
   return true;
 }
 
+bool ssl_create_preserve_tls13_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
+                                  const char *rule_str, bool strict) {
+  if (rule_str == NULL || out_cipher_list == NULL) {
+    return false;
+  }
+
+  // TLS 1.3-only ciphers.
+  static const uint16_t kAESTLS13OnlyCiphers[] = {
+      TLS1_3_CK_AES_128_GCM_SHA256 & 0xffff,
+      TLS1_3_CK_AES_256_GCM_SHA384 & 0xffff,
+      TLS1_3_CK_CHACHA20_POLY1305_SHA256 & 0xffff,
+  };
+
+  // Set up a linked list of ciphers.
+  CIPHER_ORDER co_list[std::size(kAESTLS13OnlyCiphers)];
+  for (size_t i = 0; i < std::size(co_list); i++) {
+    co_list[i].next = i + 1 < std::size(co_list) ? &co_list[i + 1] : nullptr;
+    co_list[i].prev = i == 0 ? nullptr : &co_list[i - 1];
+    co_list[i].active = false;  // Do not pre-activate
+    co_list[i].in_group = false;
+  }
+  CIPHER_ORDER *head = &co_list[0];
+  CIPHER_ORDER *tail = &co_list[std::size(co_list) - 1];
+
+  // Add TLS 1.3 ciphers to the list (but do not activate yet).
+  size_t num = 0;
+  for (uint16_t id : kAESTLS13OnlyCiphers) {
+    co_list[num++].cipher = SSL_get_cipher_by_value(id);
+    assert(co_list[num - 1].cipher != nullptr);
+    // Removed: co_list[num - 1].active = true;
+  }
+  assert(num == std::size(co_list));
+
+  // Apply rule_str to activate and order the ciphers.
+  if (!ssl_cipher_process_rulestr(rule_str, &head, &tail, strict)) {
+    return false;
+  }
+
+  // Allocate new "cipherstack" for the result.
+  UniquePtr<STACK_OF(SSL_CIPHER)> cipherstack(sk_SSL_CIPHER_new_null());
+  Array<bool> in_group_flags;
+  if (cipherstack == nullptr || !in_group_flags.Init(std::size(kAESTLS13OnlyCiphers))) {
+    return false;
+  }
+
+  // Add active ciphers to the stack in the order after applying rules.
+  size_t num_in_group_flags = 0;
+  for (CIPHER_ORDER *curr = head; curr != NULL; curr = curr->next) {
+    if (curr->active) {
+      if (!sk_SSL_CIPHER_push(cipherstack.get(), curr->cipher)) {
+        return false;
+      }
+      in_group_flags[num_in_group_flags++] = curr->in_group;
+    }
+  }
+
+  UniquePtr<SSLCipherPreferenceList> pref_list = MakeUnique<SSLCipherPreferenceList>();
+  if (!pref_list || !pref_list->Init(std::move(cipherstack), MakeConstSpan(in_group_flags).subspan(0, num_in_group_flags))) {
+    return false;
+  }
+
+  *out_cipher_list = std::move(pref_list);
+  return true;
+}
+
+
 bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
                             const bool has_aes_hw, const char *rule_str,
                             bool strict) {
@@ -1021,11 +1280,18 @@ bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
       SSL_CIPHER_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256,
   };
   static const uint16_t kLegacyCiphers[] = {
+      SSL_CIPHER_RSA_WITH_AES_128_SHA256,
+      SSL_CIPHER_RSA_WITH_AES_256_SHA256,
+      SSL_CIPHER_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
+      SSL_CIPHER_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
       SSL_CIPHER_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       SSL_CIPHER_ECDHE_RSA_WITH_AES_128_CBC_SHA,
       SSL_CIPHER_ECDHE_PSK_WITH_AES_128_CBC_SHA,
       SSL_CIPHER_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      SSL_CIPHER_ECDHE_ECDSA_WITH_AES_128_SHA256,
+      SSL_CIPHER_ECDHE_ECDSA_WITH_AES_256_SHA384,
       SSL_CIPHER_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      SSL_CIPHER_ECDHE_RSA_WITH_AES_256_SHA384,
       SSL_CIPHER_ECDHE_PSK_WITH_AES_256_CBC_SHA,
       SSL_CIPHER_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
       SSL_CIPHER_RSA_WITH_AES_128_GCM_SHA256,
@@ -1035,6 +1301,12 @@ bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
       SSL_CIPHER_RSA_WITH_AES_256_CBC_SHA,
       SSL_CIPHER_PSK_WITH_AES_256_CBC_SHA,
       SSL_CIPHER_RSA_WITH_3DES_EDE_CBC_SHA,
+      SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA,
+      SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA,
+      SSL_CIPHER_DHE_RSA_WITH_AES_128_SHA256,
+      SSL_CIPHER_DHE_RSA_WITH_AES_256_SHA256,
+      SSL_CIPHER_DHE_RSA_WITH_AES_128_GCM_SHA256,
+      SSL_CIPHER_DHE_RSA_WITH_AES_256_GCM_SHA384,
   };
 
   // Set up a linked list of ciphers.
@@ -1263,6 +1535,8 @@ int SSL_CIPHER_get_digest_nid(const SSL_CIPHER *cipher) {
       return NID_sha1;
     case SSL_SHA256:
       return NID_sha256;
+    case SSL_SHA384:
+      return NID_sha384;
   }
   assert(0);
   return NID_undef;
@@ -1527,6 +1801,10 @@ const char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf,
       mac = "SHA256";
       break;
 
+    case SSL_SHA384:
+      mac = "SHA384";
+      break;
+
     case SSL_AEAD:
       mac = "AEAD";
       break;
diff --git a/ssl/ssl_key_share.cc b/ssl/ssl_key_share.cc
index 4fb08906b..7abbd3078 100644
--- a/ssl/ssl_key_share.cc
+++ b/ssl/ssl_key_share.cc
@@ -546,6 +546,8 @@ constexpr NamedGroup kNamedGroups[] = {
     {NID_X25519Kyber768Draft00, SSL_GROUP_X25519_KYBER768_DRAFT00,
      "X25519Kyber768Draft00", "Xyber768D00"},
     {NID_X25519MLKEM768, SSL_GROUP_X25519_MLKEM768, "X25519MLKEM768", ""},
+    {NID_ffdhe2048, SSL_CURVE_DHE2048, "dhe2048", "ffdhe2048"},
+    {NID_ffdhe3072, SSL_CURVE_DHE3072, "dhe3072", "ffdhe3072"},
     {NID_ML_KEM_1024, SSL_GROUP_MLKEM1024, "MLKEM1024", ""},
     {NID_P256Kyber768Draft00, SSL_GROUP_P256_KYBER768_DRAFT00,
      "P256Kyber768Draft00", "P256Kyber768D00"},
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index fe5bb9bc7..2d0fe25e5 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -404,7 +404,9 @@ ssl_ctx_st::ssl_ctx_st(const SSL_METHOD *ssl_method)
       enable_early_data(false),
       aes_hw_override(false),
       aes_hw_override_value(false),
-      resumption_across_names_enabled(false) {
+      resumption_across_names_enabled(false),
+      key_shares_limit(0),
+      preserve_tls13_cipher_list(false) {
   CRYPTO_MUTEX_init(&lock);
   CRYPTO_new_ex_data(&ex_data);
 }
@@ -532,11 +534,14 @@ SSL *SSL_new(SSL_CTX *ctx) {
   ssl->config->aes_hw_override = ctx->aes_hw_override;
   ssl->config->aes_hw_override_value = ctx->aes_hw_override_value;
   ssl->config->compliance_policy = ctx->compliance_policy;
+  ssl->config->key_shares_limit = ctx->key_shares_limit;
+  ssl->config->preserve_tls13_cipher_list = ctx->preserve_tls13_cipher_list;
 
   if (!ssl->config->supported_group_list.CopyFrom(ctx->supported_group_list) ||
       !ssl->config->alpn_client_proto_list.CopyFrom(
           ctx->alpn_client_proto_list) ||
-      !ssl->config->verify_sigalgs.CopyFrom(ctx->verify_sigalgs)) {
+      !ssl->config->verify_sigalgs.CopyFrom(ctx->verify_sigalgs) ||
+      !ssl->config->delegated_credentials.CopyFrom(ctx->delegated_credentials)) {
     return nullptr;
   }
 
@@ -564,6 +569,7 @@ SSL *SSL_new(SSL_CTX *ctx) {
   ssl->config->signed_cert_timestamps_enabled =
       ctx->signed_cert_timestamps_enabled;
   ssl->config->ocsp_stapling_enabled = ctx->ocsp_stapling_enabled;
+  ssl->config->record_size_limit = ctx->record_size_limit;
   ssl->config->handoff = ctx->handoff;
   ssl->quic_method = ctx->quic_method;
 
@@ -587,8 +593,10 @@ SSL_CONFIG::SSL_CONFIG(SSL *ssl_arg)
       shed_handshake_config(false),
       jdk11_workaround(false),
       quic_use_legacy_codepoint(false),
+      key_shares_limit(0),
       permute_extensions(false),
       disable_second_keyshare(false),
+      preserve_tls13_cipher_list(false),
       alps_use_new_codepoint(true) {
   assert(ssl);
 }
@@ -2093,6 +2101,11 @@ const char *SSL_get_cipher_list(const SSL *ssl, int n) {
 int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str) {
   const bool has_aes_hw = ctx->aes_hw_override ? ctx->aes_hw_override_value
                                                : EVP_has_aes_hardware();
+
+  if (ctx->preserve_tls13_cipher_list) {
+    ssl_create_preserve_tls13_cipher_list(&ctx->tls13_cipher_list, str, false /* not strict */);
+  }
+
   return ssl_create_cipher_list(&ctx->cipher_list, has_aes_hw, str,
                                 false /* not strict */);
 }
@@ -2100,6 +2113,11 @@ int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str) {
 int SSL_CTX_set_strict_cipher_list(SSL_CTX *ctx, const char *str) {
   const bool has_aes_hw = ctx->aes_hw_override ? ctx->aes_hw_override_value
                                                : EVP_has_aes_hardware();
+
+  if (ctx->preserve_tls13_cipher_list) {
+    ssl_create_preserve_tls13_cipher_list(&ctx->tls13_cipher_list, str, true /* strict */);
+  }
+
   return ssl_create_cipher_list(&ctx->cipher_list, has_aes_hw, str,
                                 true /* strict */);
 }
@@ -2179,6 +2197,62 @@ void SSL_CTX_enable_ocsp_stapling(SSL_CTX *ctx) {
   ctx->ocsp_stapling_enabled = true;
 }
 
+void SSL_set_record_size_limit(SSL *ssl, uint16_t limit) {
+  if (!ssl->config) {
+    return;
+  }
+  ssl->config->record_size_limit = limit;
+}
+
+void SSL_CTX_set_record_size_limit(SSL_CTX *ctx, uint16_t limit) {
+  ctx->record_size_limit = limit;
+}
+
+void SSL_set_key_shares_limit(SSL *ssl, uint8_t limit) {
+  if (!ssl->config) {
+    return;
+  }
+  ssl->config->key_shares_limit = limit;
+}
+
+void SSL_CTX_set_key_shares_limit(SSL_CTX *ctx, uint8_t limit) {
+  ctx->key_shares_limit = limit;
+}
+
+void SSL_CTX_set_aes_hw_override(SSL_CTX *ctx, int override_value) {
+  if (!ctx) {
+    return;
+  }
+  
+  ctx->aes_hw_override = true;
+  ctx->aes_hw_override_value = !!override_value;
+}
+
+void SSL_set_aes_hw_override(SSL *ssl, int override_value) {
+  if (!ssl->config) {
+    return;
+  }
+
+  ssl->config->aes_hw_override = true;
+  ssl->config->aes_hw_override_value = !!override_value;
+}
+
+void SSL_CTX_set_preserve_tls13_cipher_list(SSL_CTX *ctx, int preserve_tls13_cipher_list) {
+  if (!ctx) {
+    return;
+  }
+  
+  ctx->preserve_tls13_cipher_list = !!preserve_tls13_cipher_list;
+}
+
+void SSL_set_preserve_tls13_cipher_list(SSL *ssl, int preserve_tls13_cipher_list) {
+  if (!ssl->config) {
+    return;
+  }
+
+  ssl->config->preserve_tls13_cipher_list = !!preserve_tls13_cipher_list;
+}
+
 void SSL_enable_ocsp_stapling(SSL *ssl) {
   if (!ssl->config) {
     return;
@@ -3107,6 +3181,21 @@ void SSL_set_permute_extensions(SSL *ssl, int enabled) {
   ssl->config->permute_extensions = !!enabled;
 }
 
+int SSL_CTX_set_extension_order(SSL_CTX *ctx, const uint16_t *ids, int num) {
+  Array<uint16_t> order;
+  if (num > 0) {
+      if (!order.Init(num)) {
+          return 0;
+      }
+      int i;
+      for (i = 0; i < num; i++) {
+          order[i] = ids[i];
+      }
+  }
+  ctx->extension_order = std::move(order);
+  return 1;
+}
+
 int32_t SSL_get_ticket_age_skew(const SSL *ssl) {
   return ssl->s3->ticket_age_skew;
 }
diff --git a/ssl/ssl_privkey.cc b/ssl/ssl_privkey.cc
index 2346aa425..3a6ad9259 100644
--- a/ssl/ssl_privkey.cc
+++ b/ssl/ssl_privkey.cc
@@ -916,3 +916,13 @@ int SSL_set_verify_algorithm_prefs(SSL *ssl, const uint16_t *prefs,
 
   return set_sigalg_prefs(&ssl->config->verify_sigalgs, Span(prefs, num_prefs));
 }
+
+int SSL_CTX_set_delegated_credentials(SSL_CTX *ctx, const char *str) {  
+  Array<uint16_t> sigalgs;
+  if (!parse_sigalgs_list(&sigalgs, str)) {
+    return 0;
+  }
+
+  return set_sigalg_prefs(&ctx->delegated_credentials,
+                          MakeConstSpan(sigalgs.data(), sigalgs.size()));
+}
-- 
2.51.2

